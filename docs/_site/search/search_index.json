{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"splatlog Python logger that accepts ** values and prints 'em out. Because I'll forget, and because I know I'll look here when I do... Development ./dev/bin/setup Building Docs poetry run novella -d ./docs Serving them: poetry run novella -d ./docs --serve Running Tests All of them: poetry run dr.t ./splatlog/**/*.py ./docs/content/**/*.md Single file, fail-fast, printing header panel (so you can find where they start and end easily during repeated runs): poetry run dr.t -fp <filename> Publishing Update the version in pyproject.toml . Commit, tag vX.Y.Z , push. Log in to PyPI and go to https://pypi.org/manage/account/ to generate an API token. Throw poetry at it: poetry publish --build --username __token__ --password <token> Bump patch by 1 and append a0 , commit and push (now we're on the \"alpha\" of the next patch version).","title":"Home"},{"location":"#splatlog","text":"Python logger that accepts ** values and prints 'em out. Because I'll forget, and because I know I'll look here when I do...","title":"splatlog"},{"location":"#development","text":"./dev/bin/setup","title":"Development"},{"location":"#building-docs","text":"poetry run novella -d ./docs Serving them: poetry run novella -d ./docs --serve","title":"Building Docs"},{"location":"#running-tests","text":"All of them: poetry run dr.t ./splatlog/**/*.py ./docs/content/**/*.md Single file, fail-fast, printing header panel (so you can find where they start and end easily during repeated runs): poetry run dr.t -fp <filename>","title":"Running Tests"},{"location":"#publishing","text":"Update the version in pyproject.toml . Commit, tag vX.Y.Z , push. Log in to PyPI and go to https://pypi.org/manage/account/ to generate an API token. Throw poetry at it: poetry publish --build --username __token__ --password <token> Bump patch by 1 and append a0 , commit and push (now we're on the \"alpha\" of the next patch version).","title":"Publishing"},{"location":"basic-usage/","text":"Basic Usage Creating Loggers Use {@link pydoc:splatlog} to get loggers the same way you would logging . >>> import splatlog >>> log = splatlog . getLogger ( __name__ ) Note that loggers returned from getLogger are SplatLogger instances, which are logger adapters rather than being loggers themselves. This means that they extend logging.LoggerAdapter rather than logging.Logger . >>> isinstance ( log , splatlog . SplatLogger ) True >>> import logging >>> isinstance ( log , logging . Logger ) False >>> isinstance ( log , logging . LoggerAdapter ) True >>> isinstance ( log . logger , logging . Logger ) True Configuring Output As splatlog sits \"on top\" of logging , you'll need to do some one-time configuration to add handlers in order to actually see any log output. In splatlog this function is called setup , and it serves much the same purpose as logging.basicConfig . In the following example, we Set the root logger level to logging.info . Tell splatlog to write console output to sys.stderr Normally we wouldn't need this, but splatlog writes console output to sys.stderr by default, and this file is execute via doctest , which does not capture STDERR Log an info message, along with some data \"splatted\" in. >>> import sys >>> splatlog . setup ( level = \"info\" , console = sys . stdout ) >>> log . info ( \"Hello world!\" , x = 1 , y = 2 ) INFO __main__ msg Hello world ! data x int 1 y int 2 Notice that the log record is rendered in a decently readable tabular format. We use rich for that. When it's actually in your console it will also have pretty colors.","title":"Basic usage"},{"location":"basic-usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"basic-usage/#creating-loggers","text":"Use {@link pydoc:splatlog} to get loggers the same way you would logging . >>> import splatlog >>> log = splatlog . getLogger ( __name__ ) Note that loggers returned from getLogger are SplatLogger instances, which are logger adapters rather than being loggers themselves. This means that they extend logging.LoggerAdapter rather than logging.Logger . >>> isinstance ( log , splatlog . SplatLogger ) True >>> import logging >>> isinstance ( log , logging . Logger ) False >>> isinstance ( log , logging . LoggerAdapter ) True >>> isinstance ( log . logger , logging . Logger ) True","title":"Creating Loggers"},{"location":"basic-usage/#configuring-output","text":"As splatlog sits \"on top\" of logging , you'll need to do some one-time configuration to add handlers in order to actually see any log output. In splatlog this function is called setup , and it serves much the same purpose as logging.basicConfig . In the following example, we Set the root logger level to logging.info . Tell splatlog to write console output to sys.stderr Normally we wouldn't need this, but splatlog writes console output to sys.stderr by default, and this file is execute via doctest , which does not capture STDERR Log an info message, along with some data \"splatted\" in. >>> import sys >>> splatlog . setup ( level = \"info\" , console = sys . stdout ) >>> log . info ( \"Hello world!\" , x = 1 , y = 2 ) INFO __main__ msg Hello world ! data x int 1 y int 2 Notice that the log record is rendered in a decently readable tabular format. We use rich for that. When it's actually in your console it will also have pretty colors.","title":"Configuring Output"},{"location":"features/named-handlers/","text":"Named Handlers Feature Overview Splatlog has an idea of named handlers which: Have a unique, non-empty name (type str ). Allow get, set and delete by name , like a global version of a property . Have an associated cast function that creates instances from simple and convenient values (type (object) -> None | logging.Handler ). For instance, a cast function might accept a typing.IO and return a handler that writes to that I/O stream. There are two built-in named handlers : console \u2014 For logging to STDIO. Defaults to using RichHandler to produce nice, tabular output. Intended for people to read. export \u2014 For exporting logs in machine readable format for another system to consume. The cast function helps writing JSON to files and streams using the splatlog.json functionality. You can easily add your own named handlers as well. The motivation is: Encode best practices for configuring handlers for common purposes (I want to log to the console, I want to log to a file, etc.). Make handlers easy to access, inspect and replace. Usage Console Handler Say you simply want to log to the console. You can do this: >>> import splatlog >>> splatlog . setup ( console = True ) That creates a RichHandler logging to sys.stderr and adds it to the root logger. Check it out: >>> import logging >>> import sys >>> console_handler = splatlog . get_named_handler ( \"console\" ) >>> console_handler in logging . getLogger () . handlers True >>> console_handler . console . file is sys . stderr True Since doctest doesn't capture STDERR, let's log to STDOUT instead. >>> splatlog . set_named_handler ( \"console\" , sys . stdout ) >>> log = splatlog . getLogger ( __name__ ) >>> log . warning ( \"Now we're talking!\" ) WARNING __main__ msg Now we 're talking! Notice that the first handler we created is no logger attached, but our new STDOUT one is. Named handlers takes care of all this for ya. >>> console_handler in logging . getLogger () . handlers False >>> new_console_handler = splatlog . get_named_handler ( \"console\" ) >>> new_console_handler in logging . getLogger () . handlers True >>> new_console_handler . console . file is sys . stdout True You can remove the handler, setting it back to None like: >>> splatlog . set_named_handler ( \"console\" , None ) Export Handler Suppose you'd like to dump all your logs to a file or stream for processing by an external system. In this example we use a temporary directory for testing purposes, and a \"pretty\" JSON formatting to make the output easier for us humans to read, but the approach is applicable in general. First, just some imports and file preperation. >>> from tempfile import TemporaryDirectory >>> tmp = TemporaryDirectory () >>> filename = f \" { tmp . name } /log.json\" Now we setup Splatlog, setting the level to DEBUG so we get all the logs, and configuring an export handler to write to our temporary file using the \"pretty\" formatting. >>> splatlog . setup ( ... level = splatlog . DEBUG , ... export = dict ( filename = filename , formatter = \"pretty\" ) ... ) Now let's emit some logs and check out the file contents! >>> log = splatlog . getLogger ( __name__ ) >>> log . info ( \"File style!\" ) >>> log . debug ( \"Some values\" , x = 1 , y = 22 ) >>> with open ( filename , \"r\" ) as file : ... print ( file . read ()) { \"t\" : ... , \"level\" : \"INFO\" , \"name\" : \"__main__\" , \"file\" : \"<doctest named-handlers.md[...]>\" , \"line\" : 1 , \"msg\" : \"File style!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"__main__\" , \"file\" : \"<doctest named-handlers.md[...]>\" , \"line\" : 1 , \"msg\" : \"Some values\" , \"data\" : { \"x\" : 1 , \"y\" : 22 } } Seems to work pretty well. You can of course setup both console and export handlers; the verbosity feature page has a nice example using the verbosity system to control log levels in a useful way. Custom Handlers You can add your own named handlers , and setup will treat them the same as console and export . I don't have any great ideas at the moment regarding what would make sense to add, but the whole feature came about from wanting the export handler, so it doesn't seem too crazy to think that something else may make sense given some use case at some point. The following example creates a \"basic\" handler that is like the ones logging.basicConfig sets up but handles the \"splat\" of data when it's present. First, some imports we'll need. >>> from typing import Optional >>> import io >>> from collections.abc import Mapping Here we create the \"splat\" version of basic logging formatting (the default formatting when you use logging.basicConfig ). When a SplatLogger is used to log, the record will have a data dictionary attached as an attribute. If regular logging.Logger is used, data won't be there. So, what we do is create a subclass of logging.Formatter that creates an additional _splat_style that appends \" %(data)s\" to the format string. Then we override logging.Formatter.FormatMessage to switch styles when the data attribute is present (and not empty). Since this is simply to serve as an example, the \"style type\" is fixed to \"%\" , which coresponds to logging.PercentStyle . >>> class SplatFormatter ( logging . Formatter ): ... def __init__ ( ... self , ... fmt = logging . BASIC_FORMAT , ... datefmt = None , ... validate = True , ... * , ... defaults = None , ... splat_fmt = \" %(data)r \" , ... ): ... super () . __init__ ( fmt , datefmt , \"%\" , validate , defaults = defaults ) ... self . _splat_style = logging . PercentStyle ( ... fmt + \" \" + splat_fmt , ... defaults = defaults ... ) ... if validate : ... self . _splat_style . validate () ... ... def formatMessage ( self , record : logging . LogRecord ): ... if getattr ( record , \"data\" , None ): ... return self . _splat_style . format ( record ) ... return super () . formatMessage ( record ) Now we register the basic named handler , which you can do with a decorator around the cast function. You can do all sorts of fancy things in the cast function if you like, but our example is minimal: It maps None and False to None , which means \"no handler\". It maps \"text I/O\" objects to a logging.StreamHandler using our SplatFormatter that write to that I/O. It raises on anything else. \ud83d\udcdd NOTE By convention, cast functions map both None and False to None , which results in the named handler being set to None . The reason for this is that setup considers None to be a \"not provided\" value with regard to named handlers and ignores it when it sees it. On the other hand False will be passed through to the cast function, resulting in the named handled being set to None . >>> @splatlog . named_handler ( \"basic\" ) ... def cast_basic_handler ( value : object ) -> Optional [ logging . Handler ]: ... if value is None or value is False : ... return None ... if isinstance ( value , io . TextIOBase ): ... handler = logging . StreamHandler ( stream = value ) ... handler . setFormatter ( SplatFormatter ()) ... return handler ... raise TypeError ( \"bad value\" ) Next we create a io.StringIO instance to write to and call setup : Setting to root log level to logging.INFO . Unsetting any console and export handlers we may have added above. Sending our io.StringIO to be cast to a \"basic\" handler. >>> stream = io . StringIO () >>> splatlog . setup ( ... level = logging . INFO , ... console = False , ... export = False , ... basic = stream , ... ) Let's test out a \"splat\" logging with attached data . >>> log = splatlog . getLogger ( __name__ ) >>> log . info ( \"Howdy\" , a = \"aye!\" , b = \"bee\" ) >>> print ( stream . getvalue ()) INFO : __main__ : Howdy { 'a' : 'aye!' , 'b' : 'bee' } And also a \"stdlib\" logging. >>> builtin_log = logging . getLogger ( __name__ ) >>> builtin_log . info ( \"Doody\" ) >>> print ( stream . getvalue ()) INFO : __main__ : Howdy { 'a' : 'aye!' , 'b' : 'bee' } INFO : __main__ : Doody Both of which succeed in the expected manner.","title":"Named handlers"},{"location":"features/named-handlers/#named-handlers-feature","text":"","title":"Named Handlers Feature"},{"location":"features/named-handlers/#overview","text":"Splatlog has an idea of named handlers which: Have a unique, non-empty name (type str ). Allow get, set and delete by name , like a global version of a property . Have an associated cast function that creates instances from simple and convenient values (type (object) -> None | logging.Handler ). For instance, a cast function might accept a typing.IO and return a handler that writes to that I/O stream. There are two built-in named handlers : console \u2014 For logging to STDIO. Defaults to using RichHandler to produce nice, tabular output. Intended for people to read. export \u2014 For exporting logs in machine readable format for another system to consume. The cast function helps writing JSON to files and streams using the splatlog.json functionality. You can easily add your own named handlers as well. The motivation is: Encode best practices for configuring handlers for common purposes (I want to log to the console, I want to log to a file, etc.). Make handlers easy to access, inspect and replace.","title":"Overview"},{"location":"features/named-handlers/#usage","text":"","title":"Usage"},{"location":"features/named-handlers/#console-handler","text":"Say you simply want to log to the console. You can do this: >>> import splatlog >>> splatlog . setup ( console = True ) That creates a RichHandler logging to sys.stderr and adds it to the root logger. Check it out: >>> import logging >>> import sys >>> console_handler = splatlog . get_named_handler ( \"console\" ) >>> console_handler in logging . getLogger () . handlers True >>> console_handler . console . file is sys . stderr True Since doctest doesn't capture STDERR, let's log to STDOUT instead. >>> splatlog . set_named_handler ( \"console\" , sys . stdout ) >>> log = splatlog . getLogger ( __name__ ) >>> log . warning ( \"Now we're talking!\" ) WARNING __main__ msg Now we 're talking! Notice that the first handler we created is no logger attached, but our new STDOUT one is. Named handlers takes care of all this for ya. >>> console_handler in logging . getLogger () . handlers False >>> new_console_handler = splatlog . get_named_handler ( \"console\" ) >>> new_console_handler in logging . getLogger () . handlers True >>> new_console_handler . console . file is sys . stdout True You can remove the handler, setting it back to None like: >>> splatlog . set_named_handler ( \"console\" , None )","title":"Console Handler"},{"location":"features/named-handlers/#export-handler","text":"Suppose you'd like to dump all your logs to a file or stream for processing by an external system. In this example we use a temporary directory for testing purposes, and a \"pretty\" JSON formatting to make the output easier for us humans to read, but the approach is applicable in general. First, just some imports and file preperation. >>> from tempfile import TemporaryDirectory >>> tmp = TemporaryDirectory () >>> filename = f \" { tmp . name } /log.json\" Now we setup Splatlog, setting the level to DEBUG so we get all the logs, and configuring an export handler to write to our temporary file using the \"pretty\" formatting. >>> splatlog . setup ( ... level = splatlog . DEBUG , ... export = dict ( filename = filename , formatter = \"pretty\" ) ... ) Now let's emit some logs and check out the file contents! >>> log = splatlog . getLogger ( __name__ ) >>> log . info ( \"File style!\" ) >>> log . debug ( \"Some values\" , x = 1 , y = 22 ) >>> with open ( filename , \"r\" ) as file : ... print ( file . read ()) { \"t\" : ... , \"level\" : \"INFO\" , \"name\" : \"__main__\" , \"file\" : \"<doctest named-handlers.md[...]>\" , \"line\" : 1 , \"msg\" : \"File style!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"__main__\" , \"file\" : \"<doctest named-handlers.md[...]>\" , \"line\" : 1 , \"msg\" : \"Some values\" , \"data\" : { \"x\" : 1 , \"y\" : 22 } } Seems to work pretty well. You can of course setup both console and export handlers; the verbosity feature page has a nice example using the verbosity system to control log levels in a useful way.","title":"Export Handler"},{"location":"features/named-handlers/#custom-handlers","text":"You can add your own named handlers , and setup will treat them the same as console and export . I don't have any great ideas at the moment regarding what would make sense to add, but the whole feature came about from wanting the export handler, so it doesn't seem too crazy to think that something else may make sense given some use case at some point. The following example creates a \"basic\" handler that is like the ones logging.basicConfig sets up but handles the \"splat\" of data when it's present. First, some imports we'll need. >>> from typing import Optional >>> import io >>> from collections.abc import Mapping Here we create the \"splat\" version of basic logging formatting (the default formatting when you use logging.basicConfig ). When a SplatLogger is used to log, the record will have a data dictionary attached as an attribute. If regular logging.Logger is used, data won't be there. So, what we do is create a subclass of logging.Formatter that creates an additional _splat_style that appends \" %(data)s\" to the format string. Then we override logging.Formatter.FormatMessage to switch styles when the data attribute is present (and not empty). Since this is simply to serve as an example, the \"style type\" is fixed to \"%\" , which coresponds to logging.PercentStyle . >>> class SplatFormatter ( logging . Formatter ): ... def __init__ ( ... self , ... fmt = logging . BASIC_FORMAT , ... datefmt = None , ... validate = True , ... * , ... defaults = None , ... splat_fmt = \" %(data)r \" , ... ): ... super () . __init__ ( fmt , datefmt , \"%\" , validate , defaults = defaults ) ... self . _splat_style = logging . PercentStyle ( ... fmt + \" \" + splat_fmt , ... defaults = defaults ... ) ... if validate : ... self . _splat_style . validate () ... ... def formatMessage ( self , record : logging . LogRecord ): ... if getattr ( record , \"data\" , None ): ... return self . _splat_style . format ( record ) ... return super () . formatMessage ( record ) Now we register the basic named handler , which you can do with a decorator around the cast function. You can do all sorts of fancy things in the cast function if you like, but our example is minimal: It maps None and False to None , which means \"no handler\". It maps \"text I/O\" objects to a logging.StreamHandler using our SplatFormatter that write to that I/O. It raises on anything else. \ud83d\udcdd NOTE By convention, cast functions map both None and False to None , which results in the named handler being set to None . The reason for this is that setup considers None to be a \"not provided\" value with regard to named handlers and ignores it when it sees it. On the other hand False will be passed through to the cast function, resulting in the named handled being set to None . >>> @splatlog . named_handler ( \"basic\" ) ... def cast_basic_handler ( value : object ) -> Optional [ logging . Handler ]: ... if value is None or value is False : ... return None ... if isinstance ( value , io . TextIOBase ): ... handler = logging . StreamHandler ( stream = value ) ... handler . setFormatter ( SplatFormatter ()) ... return handler ... raise TypeError ( \"bad value\" ) Next we create a io.StringIO instance to write to and call setup : Setting to root log level to logging.INFO . Unsetting any console and export handlers we may have added above. Sending our io.StringIO to be cast to a \"basic\" handler. >>> stream = io . StringIO () >>> splatlog . setup ( ... level = logging . INFO , ... console = False , ... export = False , ... basic = stream , ... ) Let's test out a \"splat\" logging with attached data . >>> log = splatlog . getLogger ( __name__ ) >>> log . info ( \"Howdy\" , a = \"aye!\" , b = \"bee\" ) >>> print ( stream . getvalue ()) INFO : __main__ : Howdy { 'a' : 'aye!' , 'b' : 'bee' } And also a \"stdlib\" logging. >>> builtin_log = logging . getLogger ( __name__ ) >>> builtin_log . info ( \"Doody\" ) >>> print ( stream . getvalue ()) INFO : __main__ : Howdy { 'a' : 'aye!' , 'b' : 'bee' } INFO : __main__ : Doody Both of which succeed in the expected manner.","title":"Custom Handlers"},{"location":"features/verbosity/","text":"Verbosity Feature Splatlog has a verbosity system that allows you to configure which loggers are set to which level as you twist the knob on a single verbosity parameter. Verbosity Values ( splatlog.typing.Verbosity ) A verbosity is an int . It can not be negative. It must be less than sys.maxint . In practice it usually ranges from 0 to 4 -or-so. The higher the verbosity, the more logging you see. You can test if a value is a verbosity with splatlog.typings.isVerbosity and cast to a verbosity with splatlog.typings.asVerbosity . See documentation for those function for examples. Verbosity is directly inspired by the -v , -vv , -vvv , ... pattern of option flags common in command line interfaces on unix-like systems. Verbosity Levels To use verbosity, you provide a verbosity levels mapping. Each key is a logger name (type str ). The coresponding value is a sequence of tuple pairs. The first element is a verbosity , as discussed above. The second element is the log level to take effect at that verbosity. To apply verbosity levels globally, pass a mapping to setup . Here we apply verbosity levels to an example logger named verbosity-feature . Setting verbosity to 0 or 1 will set the verbosity-feature logger's level to WARNING . Setting verbosity to 2 will set the logger's level to INFO . Setting verbosity to 3 or more will set the logger's level to DEBUG . >>> import splatlog >>> splatlog . del_verbosity_levels () >>> splatlog . del_verbosity () >>> splatlog . setup ( ... console = \"stdout\" , ... verbosity_levels = { ... \"verbosity-feature\" : ( ... ( 0 , splatlog . WARNING ), ... ( 2 , splatlog . INFO ), ... ( 3 , splatlog . DEBUG ), ... ), ... }, ... ) We can verify this behavior by getting the logger and changing the verbosity . >>> log = splatlog . get_logger ( name = \"verbosity-feature\" ) >>> log . level is splatlog . NOTSET True >>> splatlog . set_verbosity ( 0 ) >>> log . level is splatlog . WARNING True >>> splatlog . set_verbosity ( 1 ) >>> log . level is splatlog . WARNING True >>> splatlog . set_verbosity ( 2 ) >>> log . level is splatlog . INFO True >>> splatlog . set_verbosity ( 3 ) >>> log . level is splatlog . DEBUG True >>> splatlog . set_verbosity ( 4 ) >>> log . level is splatlog . DEBUG True Handler-Specific Verbosity Levels Global verbosity levels are convenient if you only have a single handler or want to control the level of logging reaching all handlers, but there are use cases where handlers have significantly different purposes and need their levels specifically controlled. The primary example is logging important information to stdio for people to look at and logging a more comprehensive set of records to a file or stream for a log management system to ingest. To support this use case, verbosity levels can be assigned to specific logging handlers instead of the loggers themselves. In this example, we will log everything from verbosity-feature to a JSON stream, and control what goes to stdout with verbosity. First, we need to quickly reset the verbosity and verbosity levels. >>> splatlog . del_verbosity_levels () >>> splatlog . del_verbosity () Now we create a JSON handler to receive records. For testing purposes this will simply write to an io.StringIO instance. We'll also use the pretty configuration to make the output easier to read. >>> import logging >>> from io import StringIO >>> json_io = StringIO () Here is the setup: The root log level is DEBUG in order to allow all records through to our JSON handler, which is assigned as the export handler. The console handler writes to stdout (doctest doesn't capture stderr!) and has the same verbosity levels configuration as the previous section. Verbosity is set to 0 to start. >>> splatlog . setup ( ... level = splatlog . DEBUG , ... export = dict ( ... stream = json_io , ... level = splatlog . DEBUG , ... formatter = \"pretty\" ... ), ... console = dict ( ... console = \"stdout\" , ... verbosity_levels = { ... \"verbosity-feature\" : ( ... ( 0 , splatlog . WARNING ), ... ( 2 , splatlog . INFO ), ... ( 3 , splatlog . DEBUG ), ... ), ... }, ... ), ... verbosity = 0 , ... ) Let's quickly confirm the setup did what we expect: >>> splatlog . get_verbosity () == 0 True >>> log . getEffectiveLevel () is splatlog . DEBUG True >>> splatlog . get_named_handler ( \"console\" ) . verbosity_levels [ log . name ] . get_level ( ... splatlog . get_verbosity (), ... ) == splatlog . WARNING True When logging a WARNING we will see it both in stdout and the JSON stream. >>> log . warning ( \"Watch out now!\" ) WARNING verbosity - feature msg Watch out now ! >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } However, when logging a DEBUG message, it will only appear in the JSON stream. >>> log . debug ( \"Won't show in stdout, because verbosity's too low!\" ) >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Won't show in stdout, because verbosity's too low!\" } Now we turn up the verbosity to see a DEBUG message appear in both. >>> splatlog . set_verbosity ( 3 ) >>> log . debug ( ... \"Ok, now we should see it in stdout\" , ... verbosity = splatlog . get_verbosity (), ... ) DEBUG verbosity - feature msg Ok , now we should see it in stdout data verbosity int 3 >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Won't show in stdout, because verbosity's too low!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Ok, now we should see it in stdout\" , \"data\" : { \"verbosity\" : 3 } }","title":"Verbosity"},{"location":"features/verbosity/#verbosity-feature","text":"Splatlog has a verbosity system that allows you to configure which loggers are set to which level as you twist the knob on a single verbosity parameter.","title":"Verbosity Feature"},{"location":"features/verbosity/#verbosity-values-splatlogtypingverbosity","text":"A verbosity is an int . It can not be negative. It must be less than sys.maxint . In practice it usually ranges from 0 to 4 -or-so. The higher the verbosity, the more logging you see. You can test if a value is a verbosity with splatlog.typings.isVerbosity and cast to a verbosity with splatlog.typings.asVerbosity . See documentation for those function for examples. Verbosity is directly inspired by the -v , -vv , -vvv , ... pattern of option flags common in command line interfaces on unix-like systems.","title":"Verbosity Values (splatlog.typing.Verbosity)"},{"location":"features/verbosity/#verbosity-levels","text":"To use verbosity, you provide a verbosity levels mapping. Each key is a logger name (type str ). The coresponding value is a sequence of tuple pairs. The first element is a verbosity , as discussed above. The second element is the log level to take effect at that verbosity. To apply verbosity levels globally, pass a mapping to setup . Here we apply verbosity levels to an example logger named verbosity-feature . Setting verbosity to 0 or 1 will set the verbosity-feature logger's level to WARNING . Setting verbosity to 2 will set the logger's level to INFO . Setting verbosity to 3 or more will set the logger's level to DEBUG . >>> import splatlog >>> splatlog . del_verbosity_levels () >>> splatlog . del_verbosity () >>> splatlog . setup ( ... console = \"stdout\" , ... verbosity_levels = { ... \"verbosity-feature\" : ( ... ( 0 , splatlog . WARNING ), ... ( 2 , splatlog . INFO ), ... ( 3 , splatlog . DEBUG ), ... ), ... }, ... ) We can verify this behavior by getting the logger and changing the verbosity . >>> log = splatlog . get_logger ( name = \"verbosity-feature\" ) >>> log . level is splatlog . NOTSET True >>> splatlog . set_verbosity ( 0 ) >>> log . level is splatlog . WARNING True >>> splatlog . set_verbosity ( 1 ) >>> log . level is splatlog . WARNING True >>> splatlog . set_verbosity ( 2 ) >>> log . level is splatlog . INFO True >>> splatlog . set_verbosity ( 3 ) >>> log . level is splatlog . DEBUG True >>> splatlog . set_verbosity ( 4 ) >>> log . level is splatlog . DEBUG True","title":"Verbosity Levels"},{"location":"features/verbosity/#handler-specific-verbosity-levels","text":"Global verbosity levels are convenient if you only have a single handler or want to control the level of logging reaching all handlers, but there are use cases where handlers have significantly different purposes and need their levels specifically controlled. The primary example is logging important information to stdio for people to look at and logging a more comprehensive set of records to a file or stream for a log management system to ingest. To support this use case, verbosity levels can be assigned to specific logging handlers instead of the loggers themselves. In this example, we will log everything from verbosity-feature to a JSON stream, and control what goes to stdout with verbosity. First, we need to quickly reset the verbosity and verbosity levels. >>> splatlog . del_verbosity_levels () >>> splatlog . del_verbosity () Now we create a JSON handler to receive records. For testing purposes this will simply write to an io.StringIO instance. We'll also use the pretty configuration to make the output easier to read. >>> import logging >>> from io import StringIO >>> json_io = StringIO () Here is the setup: The root log level is DEBUG in order to allow all records through to our JSON handler, which is assigned as the export handler. The console handler writes to stdout (doctest doesn't capture stderr!) and has the same verbosity levels configuration as the previous section. Verbosity is set to 0 to start. >>> splatlog . setup ( ... level = splatlog . DEBUG , ... export = dict ( ... stream = json_io , ... level = splatlog . DEBUG , ... formatter = \"pretty\" ... ), ... console = dict ( ... console = \"stdout\" , ... verbosity_levels = { ... \"verbosity-feature\" : ( ... ( 0 , splatlog . WARNING ), ... ( 2 , splatlog . INFO ), ... ( 3 , splatlog . DEBUG ), ... ), ... }, ... ), ... verbosity = 0 , ... ) Let's quickly confirm the setup did what we expect: >>> splatlog . get_verbosity () == 0 True >>> log . getEffectiveLevel () is splatlog . DEBUG True >>> splatlog . get_named_handler ( \"console\" ) . verbosity_levels [ log . name ] . get_level ( ... splatlog . get_verbosity (), ... ) == splatlog . WARNING True When logging a WARNING we will see it both in stdout and the JSON stream. >>> log . warning ( \"Watch out now!\" ) WARNING verbosity - feature msg Watch out now ! >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } However, when logging a DEBUG message, it will only appear in the JSON stream. >>> log . debug ( \"Won't show in stdout, because verbosity's too low!\" ) >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Won't show in stdout, because verbosity's too low!\" } Now we turn up the verbosity to see a DEBUG message appear in both. >>> splatlog . set_verbosity ( 3 ) >>> log . debug ( ... \"Ok, now we should see it in stdout\" , ... verbosity = splatlog . get_verbosity (), ... ) DEBUG verbosity - feature msg Ok , now we should see it in stdout data verbosity int 3 >>> print ( json_io . getvalue ()) { \"t\" : ... , \"level\" : \"WARNING\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Watch out now!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Won't show in stdout, because verbosity's too low!\" } { \"t\" : ... , \"level\" : \"DEBUG\" , \"name\" : \"verbosity-feature\" , \"file\" : \"<doctest verbosity.md[...]>\" , \"line\" : 1 , \"msg\" : \"Ok, now we should see it in stdout\" , \"data\" : { \"verbosity\" : 3 } }","title":"Handler-Specific Verbosity Levels"},{"location":"splatlog/","text":"splatlog Root of the {@link pydoc:splatlog} package. Imports pretty much everything else, so you should only really need to import this.","title":"splatlog"},{"location":"splatlog/#splatlog","text":"Root of the {@link pydoc:splatlog} package. Imports pretty much everything else, so you should only really need to import this.","title":"splatlog"},{"location":"splatlog/_docs/","text":"splatlog._docs Shit just used in generating docs, excluded from the distributed package (because it depends on dev dependencies).","title":"_docs"},{"location":"splatlog/_docs/#splatlog_docs","text":"Shit just used in generating docs, excluded from the distributed package (because it depends on dev dependencies).","title":"splatlog._docs"},{"location":"splatlog/_testing/","text":"splatlog._testing Shit just used in tests (doctest at the moment), , excluded from the distributed package. make_log_record def make_log_record ( name : str = __name__ , level : Level = logging . INFO , pathname : str = __file__ , lineno : int = 123 , msg : str = \"Test message\" , args : Union [ tuple , dict [ str , Any ]] = (), exc_info : Optional [ ExcInfo ] = None , func : Optional [ str ] = None , sinfo : Optional [ str ] = None , * , created : Union [ None , float , datetime ] = None , data : Optional [ dict [ str , Any ]] = None ) -> logging . LogRecord [view_source] Used in testing to make logging.LogRecord instances. Provides defaults for all of the parameters, since you often only care about setting some subset. Provides a hack to set the logging.LogRecord.created attribute (as well as associated logging.LogRecord.msecs and logging.LogRecord.relativeCreated attributes) by providing an extra created keyword parameter. Also provides a way to set the data attribute by passing the extra data keyword parameter. SEE https://docs.python.org/3.10/library/logging.html#logging.LogRecord","title":"_testing"},{"location":"splatlog/_testing/#splatlog_testing","text":"Shit just used in tests (doctest at the moment), , excluded from the distributed package.","title":"splatlog._testing"},{"location":"splatlog/_testing/#make_log_record","text":"def make_log_record ( name : str = __name__ , level : Level = logging . INFO , pathname : str = __file__ , lineno : int = 123 , msg : str = \"Test message\" , args : Union [ tuple , dict [ str , Any ]] = (), exc_info : Optional [ ExcInfo ] = None , func : Optional [ str ] = None , sinfo : Optional [ str ] = None , * , created : Union [ None , float , datetime ] = None , data : Optional [ dict [ str , Any ]] = None ) -> logging . LogRecord [view_source] Used in testing to make logging.LogRecord instances. Provides defaults for all of the parameters, since you often only care about setting some subset. Provides a hack to set the logging.LogRecord.created attribute (as well as associated logging.LogRecord.msecs and logging.LogRecord.relativeCreated attributes) by providing an extra created keyword parameter. Also provides a way to set the data attribute by passing the extra data keyword parameter. SEE https://docs.python.org/3.10/library/logging.html#logging.LogRecord","title":"make_log_record"},{"location":"splatlog/levels/","text":"splatlog.levels get_level_value def get_level_value ( level : Level ) -> LevelValue [view_source] Make a logging level number from more useful/intuitive things, like string you might get from an environment variable or command option. Examples Integers Any integer is simply returned. This follows the logic in the stdlib logging package, logging._checkLevel in particular. >>> get_level_value ( logging . DEBUG ) 10 >>> get_level_value ( 123 ) 123 >>> get_level_value ( - 1 ) - 1 No, I have no idea what kind of mess using negative level values might cause. Strings Integer levels can be provided as strings. Again, they don't have to correspond to any named level. >>> get_level_value ( \"8\" ) 8 We also accept level names . >>> get_level_value ( \"debug\" ) 10 We use the oddly-named logging.getLevelName to figure out if a string is a level name (when given a string that is a level name it will return the integer level value). If we don't find the exact name we're given, we also try the upper-case version of the string. >>> get_level_value ( \"DEBUG\" ) 10 >>> get_level_value ( \"Debug\" ) 10 This works with custom levels as well. >>> logging . addLevelName ( 8 , \"LUCKY\" ) >>> get_level_value ( \"lucky\" ) 8 Other Everything else can kick rocks: >>> get_level_value ([]) Traceback ( most recent call last ): ... TypeError : Expected ` level ` to be ` int | str ` , given [ list ]( https : // docs . python . org / 3.11 / library / stdtypes . html #list): [] is_level_name def is_level_name ( name : object , * , case_sensitive : bool = False ) -> TypeGuard [ LevelName ] [view_source] Examples >>> is_level_name ( \"DEBUG\" ) True >>> is_level_name ( \"LEVEL_NAME_TEST\" ) False >>> level_value = hash ( \"LEVEL_NAME_TEST\" ) # Use somewhat unique int >>> logging . addLevelName ( level_value , \"LEVEL_NAME_TEST\" ) >>> is_level_name ( \"LEVEL_NAME_TEST\" ) True is_level_value def is_level_value ( value : object ) -> TypeGuard [ LevelValue ] [view_source] Test if value is a level value. Specifically, tests if value is a named level value \u2014 a builtin one like logging.DEBUG or a custom one added with logging.addLevelName . Technically, it seems like you can use any int as a level value, but it seems like it makes things simpler if all LevelValue have LevelName and vice-versa. Examples >>> is_level_value ( logging . DEBUG ) True >>> level_value = hash ( \"LEVEL_VALUE_TEST\" ) # Use somewhat unique int >>> is_level_value ( level_value ) False >>> logging . addLevelName ( level_value , \"LEVEL_VALUE_TEST\" ) >>> is_level_value ( level_value ) True","title":"levels"},{"location":"splatlog/levels/#splatloglevels","text":"","title":"splatlog.levels"},{"location":"splatlog/levels/#get_level_value","text":"def get_level_value ( level : Level ) -> LevelValue [view_source] Make a logging level number from more useful/intuitive things, like string you might get from an environment variable or command option.","title":"get_level_value"},{"location":"splatlog/levels/#examples","text":"","title":"Examples"},{"location":"splatlog/levels/#integers","text":"Any integer is simply returned. This follows the logic in the stdlib logging package, logging._checkLevel in particular. >>> get_level_value ( logging . DEBUG ) 10 >>> get_level_value ( 123 ) 123 >>> get_level_value ( - 1 ) - 1 No, I have no idea what kind of mess using negative level values might cause.","title":"Integers"},{"location":"splatlog/levels/#strings","text":"Integer levels can be provided as strings. Again, they don't have to correspond to any named level. >>> get_level_value ( \"8\" ) 8 We also accept level names . >>> get_level_value ( \"debug\" ) 10 We use the oddly-named logging.getLevelName to figure out if a string is a level name (when given a string that is a level name it will return the integer level value). If we don't find the exact name we're given, we also try the upper-case version of the string. >>> get_level_value ( \"DEBUG\" ) 10 >>> get_level_value ( \"Debug\" ) 10 This works with custom levels as well. >>> logging . addLevelName ( 8 , \"LUCKY\" ) >>> get_level_value ( \"lucky\" ) 8","title":"Strings"},{"location":"splatlog/levels/#other","text":"Everything else can kick rocks: >>> get_level_value ([]) Traceback ( most recent call last ): ... TypeError : Expected ` level ` to be ` int | str ` , given [ list ]( https : // docs . python . org / 3.11 / library / stdtypes . html #list): []","title":"Other"},{"location":"splatlog/levels/#is_level_name","text":"def is_level_name ( name : object , * , case_sensitive : bool = False ) -> TypeGuard [ LevelName ] [view_source]","title":"is_level_name"},{"location":"splatlog/levels/#examples_1","text":">>> is_level_name ( \"DEBUG\" ) True >>> is_level_name ( \"LEVEL_NAME_TEST\" ) False >>> level_value = hash ( \"LEVEL_NAME_TEST\" ) # Use somewhat unique int >>> logging . addLevelName ( level_value , \"LEVEL_NAME_TEST\" ) >>> is_level_name ( \"LEVEL_NAME_TEST\" ) True","title":"Examples"},{"location":"splatlog/levels/#is_level_value","text":"def is_level_value ( value : object ) -> TypeGuard [ LevelValue ] [view_source] Test if value is a level value. Specifically, tests if value is a named level value \u2014 a builtin one like logging.DEBUG or a custom one added with logging.addLevelName . Technically, it seems like you can use any int as a level value, but it seems like it makes things simpler if all LevelValue have LevelName and vice-versa.","title":"is_level_value"},{"location":"splatlog/levels/#examples_2","text":">>> is_level_value ( logging . DEBUG ) True >>> level_value = hash ( \"LEVEL_VALUE_TEST\" ) # Use somewhat unique int >>> is_level_value ( level_value ) False >>> logging . addLevelName ( level_value , \"LEVEL_VALUE_TEST\" ) >>> is_level_value ( level_value ) True","title":"Examples"},{"location":"splatlog/locking/","text":"splatlog.locking","title":"locking"},{"location":"splatlog/locking/#splatloglocking","text":"","title":"splatlog.locking"},{"location":"splatlog/named_handlers/","text":"splatlog.named_handlers Manage named handlers ... cast_console_handler @named_handler ( \"console\" ) def cast_console_handler ( value : ConsoleHandlerCastable ) -> Optional [ logging . Handler ] [view_source] Convert a value into either a logging.Handler or None . If neither of those make sense raises a TypeError . Examples True is cast to a new RichHandler with all default attributes. >>> cast_console_handler ( True ) < RichHandler ( NOTSET ) > False and None cast to None . >>> cast_console_handler ( False ) is None True >>> cast_console_handler ( None ) is None True Any logging.Handler instance is simply returned. >>> import sys >>> handler = logging . StreamHandler ( sys . stdout ) >>> cast_console_handler ( handler ) is handler True Any collections.abc.Mapping is used as the keyword arguments to construct a new RichHandler . >>> handler = cast_console_handler ( ... dict ( ... console = sys . stdout , ... verbosity_levels = dict ( ... some_mod = (( 0 , \"WARNING\" ), ( 1 , \"INFO\" )), ... ) ... ) ... ) >>> isinstance ( handler , RichHandler ) True >>> handler . console . file is sys . stdout True >>> handler . verbosity_levels { 'some_mod' : < VerbosityLevelResolver [ 0 ]: WARNING , [ 1 , ... ]: INFO > } Anything that RichHandler can cast to a rich.console.Console (see RichHandler.cast_console ) is assigned as the console in a new RichHandler instance. >>> from io import StringIO >>> sio = StringIO () >>> handler = cast_console_handler ( sio ) >>> isinstance ( handler , RichHandler ) True >>> handler . console . file is sio True >>> import sys >>> cast_console_handler ( \"stdout\" ) . console . file is sys . stdout True Any log level name or value is assigned as the level to a new RichHandler instance. >>> cast_console_handler ( logging . DEBUG ) . level == logging . DEBUG True >>> cast_console_handler ( \"DEBUG\" ) . level == logging . DEBUG True Note that in the extremely bizare case where you name a log level \"stdout\" (or \"STDOUT\" ) you can not use \"stdout\" to create a handler with that level because \"stdout\" will be cast to a RichHandler with the RichHandler.console writing to sys.stdout . >>> stdout_level_value = hash ( \"stdout\" ) # Use somewhat unique int >>> logging . addLevelName ( stdout_level_value , \"stdout\" ) >>> cast_console_handler ( \"stdout\" ) . level == stdout_level_value False Same applies for \"stderr\" . Anythings else raises a TypeError . >>> cast_console_handler ([ 1 , 2 , 3 ]) Traceback ( most recent call last ): ... TypeError : Expected None | logging . Handler | typing . Mapping [ str , typing . Any ] | bool | rich . console . Console | 'stdout' | 'stderr' | typing . IO [ str ] | int | str , given list : [ 1 , 2 , 3 ]","title":"named_handlers"},{"location":"splatlog/named_handlers/#splatlognamed_handlers","text":"Manage named handlers ...","title":"splatlog.named_handlers"},{"location":"splatlog/named_handlers/#cast_console_handler","text":"@named_handler ( \"console\" ) def cast_console_handler ( value : ConsoleHandlerCastable ) -> Optional [ logging . Handler ] [view_source] Convert a value into either a logging.Handler or None . If neither of those make sense raises a TypeError .","title":"cast_console_handler"},{"location":"splatlog/named_handlers/#examples","text":"True is cast to a new RichHandler with all default attributes. >>> cast_console_handler ( True ) < RichHandler ( NOTSET ) > False and None cast to None . >>> cast_console_handler ( False ) is None True >>> cast_console_handler ( None ) is None True Any logging.Handler instance is simply returned. >>> import sys >>> handler = logging . StreamHandler ( sys . stdout ) >>> cast_console_handler ( handler ) is handler True Any collections.abc.Mapping is used as the keyword arguments to construct a new RichHandler . >>> handler = cast_console_handler ( ... dict ( ... console = sys . stdout , ... verbosity_levels = dict ( ... some_mod = (( 0 , \"WARNING\" ), ( 1 , \"INFO\" )), ... ) ... ) ... ) >>> isinstance ( handler , RichHandler ) True >>> handler . console . file is sys . stdout True >>> handler . verbosity_levels { 'some_mod' : < VerbosityLevelResolver [ 0 ]: WARNING , [ 1 , ... ]: INFO > } Anything that RichHandler can cast to a rich.console.Console (see RichHandler.cast_console ) is assigned as the console in a new RichHandler instance. >>> from io import StringIO >>> sio = StringIO () >>> handler = cast_console_handler ( sio ) >>> isinstance ( handler , RichHandler ) True >>> handler . console . file is sio True >>> import sys >>> cast_console_handler ( \"stdout\" ) . console . file is sys . stdout True Any log level name or value is assigned as the level to a new RichHandler instance. >>> cast_console_handler ( logging . DEBUG ) . level == logging . DEBUG True >>> cast_console_handler ( \"DEBUG\" ) . level == logging . DEBUG True Note that in the extremely bizare case where you name a log level \"stdout\" (or \"STDOUT\" ) you can not use \"stdout\" to create a handler with that level because \"stdout\" will be cast to a RichHandler with the RichHandler.console writing to sys.stdout . >>> stdout_level_value = hash ( \"stdout\" ) # Use somewhat unique int >>> logging . addLevelName ( stdout_level_value , \"stdout\" ) >>> cast_console_handler ( \"stdout\" ) . level == stdout_level_value False Same applies for \"stderr\" . Anythings else raises a TypeError . >>> cast_console_handler ([ 1 , 2 , 3 ]) Traceback ( most recent call last ): ... TypeError : Expected None | logging . Handler | typing . Mapping [ str , typing . Any ] | bool | rich . console . Console | 'stdout' | 'stderr' | typing . IO [ str ] | int | str , given list : [ 1 , 2 , 3 ]","title":"Examples"},{"location":"splatlog/names/","text":"splatlog.names Helpers for working with logger / module names. Convention is to use module names as logger names, so they're kinda the same thing in practice. root_name def root_name ( module_name : str ) -> str [view_source] Get the first element of a module name. Examples >>> root_name ( \"splatlog.names\" ) 'splatlog' is_in_hierarchy def is_in_hierarchy ( hierarchy_name : str , logger_name : str ) [view_source] Examples >>> is_in_hierarchy ( \"splatlog\" , \"splatlog\" ) True >>> is_in_hierarchy ( \"splatlog\" , \"splatlog.names\" ) True >>> is_in_hierarchy ( \"blah\" , \"splatlog\" ) False >>> is_in_hierarchy ( \"splat\" , \"splatlog\" ) False","title":"names"},{"location":"splatlog/names/#splatlognames","text":"Helpers for working with logger / module names. Convention is to use module names as logger names, so they're kinda the same thing in practice.","title":"splatlog.names"},{"location":"splatlog/names/#root_name","text":"def root_name ( module_name : str ) -> str [view_source] Get the first element of a module name.","title":"root_name"},{"location":"splatlog/names/#examples","text":">>> root_name ( \"splatlog.names\" ) 'splatlog'","title":"Examples"},{"location":"splatlog/names/#is_in_hierarchy","text":"def is_in_hierarchy ( hierarchy_name : str , logger_name : str ) [view_source]","title":"is_in_hierarchy"},{"location":"splatlog/names/#examples_1","text":">>> is_in_hierarchy ( \"splatlog\" , \"splatlog\" ) True >>> is_in_hierarchy ( \"splatlog\" , \"splatlog.names\" ) True >>> is_in_hierarchy ( \"blah\" , \"splatlog\" ) False >>> is_in_hierarchy ( \"splat\" , \"splatlog\" ) False","title":"Examples"},{"location":"splatlog/rich_handler/","text":"splatlog.rich_handler Contains the RichHandler class. RichHandler class RichHandler ( SplatHandler ) [view_source] A logging.Handler extension that uses [rich][] to print pretty nice log entries to the console. Output is meant for specifically humans.","title":"rich_handler"},{"location":"splatlog/rich_handler/#splatlogrich_handler","text":"Contains the RichHandler class.","title":"splatlog.rich_handler"},{"location":"splatlog/rich_handler/#richhandler","text":"class RichHandler ( SplatHandler ) [view_source] A logging.Handler extension that uses [rich][] to print pretty nice log entries to the console. Output is meant for specifically humans.","title":"RichHandler"},{"location":"splatlog/setup/","text":"splatlog.setup setup def setup ( * , level : Optional [ Level ] = None , verbosity_levels : Optional [ VerbosityLevelsCastable ] = None , verbosity : Optional [ Verbosity ] = None , console : ConsoleHandlerCastable = None , export : ExportHandlerCastable = None , ** custom_named_handlers ) -> None [view_source] Set things up!","title":"setup"},{"location":"splatlog/setup/#splatlogsetup","text":"","title":"splatlog.setup"},{"location":"splatlog/setup/#setup","text":"def setup ( * , level : Optional [ Level ] = None , verbosity_levels : Optional [ VerbosityLevelsCastable ] = None , verbosity : Optional [ Verbosity ] = None , console : ConsoleHandlerCastable = None , export : ExportHandlerCastable = None , ** custom_named_handlers ) -> None [view_source] Set things up!","title":"setup"},{"location":"splatlog/splat_handler/","text":"splatlog.splat_handler SplatHandler class SplatHandler ( logging . Handler ) [view_source]","title":"splat_handler"},{"location":"splatlog/splat_handler/#splatlogsplat_handler","text":"","title":"splatlog.splat_handler"},{"location":"splatlog/splat_handler/#splathandler","text":"class SplatHandler ( logging . Handler ) [view_source]","title":"SplatHandler"},{"location":"splatlog/splat_logger/","text":"splatlog.splat_logger Defines SplatLogger and associated classes, as well as the global \"get\" functions like get_logger and get_logger_for (because interdependency makes it difficult or impossible to define them in separate files). get_logger @cache def get_logger ( name : str ) -> SplatLogger [view_source] The core logger-getter method, equivalent to logging.getLogger but returning a SplatLogger adapter. getLogger logging -style camel-case alias of get_logger , though we prefer to use the snake-case one in practice. get_logger_for def get_logger_for ( obj : object ) -> SplatLogger [view_source] Get a logger that is associated with an object. There are three types, depending on the type of obj : When obj is a str a regular-old named logger will be returned, same as calling get_logger . As such these instances are cached globally. When obj is a class (via inspect.isclass ) a ClassLogger instance will be returned. ClassLogger is an extension of SplatLogger (and hence a logging.LoggerAdapter ) that adapts the logging.Logger for the module the class is defined in and adds the qualified name of the class to logging.LogRecord that it processes as a class_name attribute. ClassLogger instances are not cached, and it is expected that the user will store a reference on the class for repeated use (see LoggerProperty ). When obj is anything else a SelfLogger instance will be returned. SelfLogger is an extension of ClassLogger , where: The type of obj is used to initialize ClassLogger . Hence processed logging.LogRecord will have record . class_name = obj . __class__ . __qualname__ A self attribute is added to processed logging.LogRecord to identify obj itself as the record source. See SelfLogger for details on how to hook into that. SelfLogger instances are not cached, and it is expected that the user will store a reference on the class for repeated use (see LoggerProperty ). Examples First, we'll create a \"module logger\" in the usual way. >>> module_logger = get_logger_for ( __name__ ) >>> isinstance ( module_logger , SplatLogger ) True >>> isinstance ( module_logger , ( ClassLogger , SelfLogger )) False >>> module_logger . name 'splatlog.splat_logger' Next we define a minimal class to associate loggers with. Instances have names and the _splatlog_self_ property returns a dictionary with the name. >>> class MyClass : ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) Now we can check out class and instance loggers for it. >>> class_logger = get_logger_for ( MyClass ) >>> isinstance ( class_logger , SplatLogger ) True >>> isinstance ( class_logger , ClassLogger ) True >>> isinstance ( class_logger , SelfLogger ) False >>> class_logger . name 'splatlog.splat_logger' >>> class_logger . class_name 'MyClass' >>> instance = MyClass ( name = \"xyz\" ) >>> instance_logger = get_logger_for ( instance ) >>> isinstance ( instance_logger , SelfLogger ) True >>> instance_logger . name 'splatlog.splat_logger' >>> instance_logger . class_name 'MyClass' >>> instance_logger . get_identity () { 'name' : 'xyz' } LoggerProperty class LoggerProperty () [view_source] A property that resolves to a ClassLogger when accessed through the class object and a SelfLogger when accessed through instances. The ClassLogger is cached in an attribute on the class' __dict__ and each SelfLogger is cached in an attribute on said instance. Examples A \"standard\" class. >>> class AnotherClass : ... _log = LoggerProperty () ... ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) >>> isinstance ( AnotherClass . _log , ClassLogger ) True >>> AnotherClass . _log . class_name 'AnotherClass' >>> instance = AnotherClass ( name = \"blah\" ) >>> isinstance ( instance . _log , SelfLogger ) True >>> instance . _log . class_name 'AnotherClass' >>> instance . _log . get_identity () { 'name' : 'blah' } A frozen dataclass, which has different set semantics. >>> from dataclasses import dataclass >>> @dataclass ( frozen = True ) ... class Chiller : ... _log = LoggerProperty () ... ... name : str ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) >>> isinstance ( Chiller . _log , ClassLogger ) True >>> Chiller . _log . class_name 'Chiller' >>> cold_one = Chiller ( name = \"brrrr!\" ) >>> isinstance ( cold_one . _log , SelfLogger ) True >>> cold_one . _log . class_name 'Chiller' >>> cold_one . _log . get_identity () { 'name' : 'brrrr!' } SplatLogger class SplatLogger ( logging . LoggerAdapter ) [view_source] \\ A logging.Logger extension that overrides the logging.Logger._log method the underlies all \"log methods\" ( logging.Logger.debug , logging.Logger.info , etc) to treat the double-splat keyword arguments as a map of names to values to be logged. This map is added as \"data\" to the extra mapping that is part of the log method API, where it eventually is assigned as a data attribute on the emitted logging.LogRecord . This allows logging invocations like: logger.debug( \"Check this out!\", x=\"hey, y=\"ho\", z={\"lets\": \"go\"}, ) which I (obviously) like much better. addHandler def addHandler ( hdlr : logging . Handler ) -> None [view_source] Delegate to the underlying logger. removeHandler def removeHandler ( hdlr : logging . Handler ) -> None [view_source] Delegate to the underlying logger. ClassLogger class ClassLogger ( SplatLogger ) [view_source] ClassLogger is an extension of SplatLogger (and hence a logging.LoggerAdapter ) that adapts the logging.Logger for the module the class is defined in and adds the qualified name of the class to logging.LogRecord that it processes as a class_name attribute. SelfLogger class SelfLogger ( ClassLogger ) [view_source] SelfLogger is an extension of ClassLogger , where for an object obj : The type of obj is used to initialize ClassLogger . Hence processed logging.LogRecord will have record . class_name = obj . __class__ . __qualname__ A self attribute is added to processed logging.LogRecord to identify obj itself as the record source. See SelfLogger for details on how to hook into that. If obj has an attribute named _splatlog_self_ then the value of that attribute is used as record.self . If the attribute value is a typing.Callable then it will be called (with no arguments) each and every time that a record is processed by the SelfLogger to get the value for record.self . This allows for dynamic identity , but between performance overhead and possible confusion you probably shouldn't use it unless you've thoroughly thought it through. If no _splatlog_self_ attribute is present on obj then a hex representation of it's unique object id will be used: hex ( id ( obj ))","title":"splat_logger"},{"location":"splatlog/splat_logger/#splatlogsplat_logger","text":"Defines SplatLogger and associated classes, as well as the global \"get\" functions like get_logger and get_logger_for (because interdependency makes it difficult or impossible to define them in separate files).","title":"splatlog.splat_logger"},{"location":"splatlog/splat_logger/#get_logger","text":"@cache def get_logger ( name : str ) -> SplatLogger [view_source] The core logger-getter method, equivalent to logging.getLogger but returning a SplatLogger adapter.","title":"get_logger"},{"location":"splatlog/splat_logger/#getlogger","text":"logging -style camel-case alias of get_logger , though we prefer to use the snake-case one in practice.","title":"getLogger"},{"location":"splatlog/splat_logger/#get_logger_for","text":"def get_logger_for ( obj : object ) -> SplatLogger [view_source] Get a logger that is associated with an object. There are three types, depending on the type of obj : When obj is a str a regular-old named logger will be returned, same as calling get_logger . As such these instances are cached globally. When obj is a class (via inspect.isclass ) a ClassLogger instance will be returned. ClassLogger is an extension of SplatLogger (and hence a logging.LoggerAdapter ) that adapts the logging.Logger for the module the class is defined in and adds the qualified name of the class to logging.LogRecord that it processes as a class_name attribute. ClassLogger instances are not cached, and it is expected that the user will store a reference on the class for repeated use (see LoggerProperty ). When obj is anything else a SelfLogger instance will be returned. SelfLogger is an extension of ClassLogger , where: The type of obj is used to initialize ClassLogger . Hence processed logging.LogRecord will have record . class_name = obj . __class__ . __qualname__ A self attribute is added to processed logging.LogRecord to identify obj itself as the record source. See SelfLogger for details on how to hook into that. SelfLogger instances are not cached, and it is expected that the user will store a reference on the class for repeated use (see LoggerProperty ).","title":"get_logger_for"},{"location":"splatlog/splat_logger/#examples","text":"First, we'll create a \"module logger\" in the usual way. >>> module_logger = get_logger_for ( __name__ ) >>> isinstance ( module_logger , SplatLogger ) True >>> isinstance ( module_logger , ( ClassLogger , SelfLogger )) False >>> module_logger . name 'splatlog.splat_logger' Next we define a minimal class to associate loggers with. Instances have names and the _splatlog_self_ property returns a dictionary with the name. >>> class MyClass : ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) Now we can check out class and instance loggers for it. >>> class_logger = get_logger_for ( MyClass ) >>> isinstance ( class_logger , SplatLogger ) True >>> isinstance ( class_logger , ClassLogger ) True >>> isinstance ( class_logger , SelfLogger ) False >>> class_logger . name 'splatlog.splat_logger' >>> class_logger . class_name 'MyClass' >>> instance = MyClass ( name = \"xyz\" ) >>> instance_logger = get_logger_for ( instance ) >>> isinstance ( instance_logger , SelfLogger ) True >>> instance_logger . name 'splatlog.splat_logger' >>> instance_logger . class_name 'MyClass' >>> instance_logger . get_identity () { 'name' : 'xyz' }","title":"Examples"},{"location":"splatlog/splat_logger/#loggerproperty","text":"class LoggerProperty () [view_source] A property that resolves to a ClassLogger when accessed through the class object and a SelfLogger when accessed through instances. The ClassLogger is cached in an attribute on the class' __dict__ and each SelfLogger is cached in an attribute on said instance.","title":"LoggerProperty"},{"location":"splatlog/splat_logger/#examples_1","text":"A \"standard\" class. >>> class AnotherClass : ... _log = LoggerProperty () ... ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) >>> isinstance ( AnotherClass . _log , ClassLogger ) True >>> AnotherClass . _log . class_name 'AnotherClass' >>> instance = AnotherClass ( name = \"blah\" ) >>> isinstance ( instance . _log , SelfLogger ) True >>> instance . _log . class_name 'AnotherClass' >>> instance . _log . get_identity () { 'name' : 'blah' } A frozen dataclass, which has different set semantics. >>> from dataclasses import dataclass >>> @dataclass ( frozen = True ) ... class Chiller : ... _log = LoggerProperty () ... ... name : str ... ... @property ... def _splatlog_self_ ( self ) -> object : ... return dict ( name = self . name ) >>> isinstance ( Chiller . _log , ClassLogger ) True >>> Chiller . _log . class_name 'Chiller' >>> cold_one = Chiller ( name = \"brrrr!\" ) >>> isinstance ( cold_one . _log , SelfLogger ) True >>> cold_one . _log . class_name 'Chiller' >>> cold_one . _log . get_identity () { 'name' : 'brrrr!' }","title":"Examples"},{"location":"splatlog/splat_logger/#splatlogger","text":"class SplatLogger ( logging . LoggerAdapter ) [view_source] \\ A logging.Logger extension that overrides the logging.Logger._log method the underlies all \"log methods\" ( logging.Logger.debug , logging.Logger.info , etc) to treat the double-splat keyword arguments as a map of names to values to be logged. This map is added as \"data\" to the extra mapping that is part of the log method API, where it eventually is assigned as a data attribute on the emitted logging.LogRecord . This allows logging invocations like: logger.debug( \"Check this out!\", x=\"hey, y=\"ho\", z={\"lets\": \"go\"}, ) which I (obviously) like much better.","title":"SplatLogger"},{"location":"splatlog/splat_logger/#addhandler","text":"def addHandler ( hdlr : logging . Handler ) -> None [view_source] Delegate to the underlying logger.","title":"addHandler"},{"location":"splatlog/splat_logger/#removehandler","text":"def removeHandler ( hdlr : logging . Handler ) -> None [view_source] Delegate to the underlying logger.","title":"removeHandler"},{"location":"splatlog/splat_logger/#classlogger","text":"class ClassLogger ( SplatLogger ) [view_source] ClassLogger is an extension of SplatLogger (and hence a logging.LoggerAdapter ) that adapts the logging.Logger for the module the class is defined in and adds the qualified name of the class to logging.LogRecord that it processes as a class_name attribute.","title":"ClassLogger"},{"location":"splatlog/splat_logger/#selflogger","text":"class SelfLogger ( ClassLogger ) [view_source] SelfLogger is an extension of ClassLogger , where for an object obj : The type of obj is used to initialize ClassLogger . Hence processed logging.LogRecord will have record . class_name = obj . __class__ . __qualname__ A self attribute is added to processed logging.LogRecord to identify obj itself as the record source. See SelfLogger for details on how to hook into that. If obj has an attribute named _splatlog_self_ then the value of that attribute is used as record.self . If the attribute value is a typing.Callable then it will be called (with no arguments) each and every time that a record is processed by the SelfLogger to get the value for record.self . This allows for dynamic identity , but between performance overhead and possible confusion you probably shouldn't use it unless you've thoroughly thought it through. If no _splatlog_self_ attribute is present on obj then a hex representation of it's unique object id will be used: hex ( id ( obj ))","title":"SelfLogger"},{"location":"splatlog/typings/","text":"splatlog.typings is_verbosity def is_verbosity ( x : object ) -> TypeGuard [ Verbosity ] [view_source] Test if a value is a verbosity . Examples >>> is_verbosity ( 0 ) True >>> is_verbosity ( 8 ) True >>> is_verbosity ( - 1 ) False >>> import sys >>> is_verbosity ( sys . maxsize ) False >>> is_verbosity ( sys . maxsize - 1 ) True as_verbosity def as_verbosity ( x : object ) -> Verbosity [view_source] Cast a value to a verbosity , raising TypeError if unsuccessful. Examples >>> as_verbosity ( 0 ) 0 >>> as_verbosity ( 8 ) 8 >>> as_verbosity ( - 1 ) Traceback ( most recent call last ): ... TypeError : Expected verbosity to be non - negative integer less than [ sys . maxsize ]( https : // docs . python . org / 3.11 / library / sys . html #sys.maxsize), given int: -1","title":"typings"},{"location":"splatlog/typings/#splatlogtypings","text":"","title":"splatlog.typings"},{"location":"splatlog/typings/#is_verbosity","text":"def is_verbosity ( x : object ) -> TypeGuard [ Verbosity ] [view_source] Test if a value is a verbosity .","title":"is_verbosity"},{"location":"splatlog/typings/#examples","text":">>> is_verbosity ( 0 ) True >>> is_verbosity ( 8 ) True >>> is_verbosity ( - 1 ) False >>> import sys >>> is_verbosity ( sys . maxsize ) False >>> is_verbosity ( sys . maxsize - 1 ) True","title":"Examples"},{"location":"splatlog/typings/#as_verbosity","text":"def as_verbosity ( x : object ) -> Verbosity [view_source] Cast a value to a verbosity , raising TypeError if unsuccessful.","title":"as_verbosity"},{"location":"splatlog/typings/#examples_1","text":">>> as_verbosity ( 0 ) 0 >>> as_verbosity ( 8 ) 8 >>> as_verbosity ( - 1 ) Traceback ( most recent call last ): ... TypeError : Expected verbosity to be non - negative integer less than [ sys . maxsize ]( https : // docs . python . org / 3.11 / library / sys . html #sys.maxsize), given int: -1","title":"Examples"},{"location":"splatlog/json/","text":"splatlog.json","title":"splatlog.json"},{"location":"splatlog/json/#splatlogjson","text":"","title":"splatlog.json"},{"location":"splatlog/json/default_handlers/","text":"splatlog.json.default_handlers","title":"default_handlers"},{"location":"splatlog/json/default_handlers/#splatlogjsondefault_handlers","text":"","title":"splatlog.json.default_handlers"},{"location":"splatlog/json/json_encoder/","text":"splatlog.json.json_encoder JSONEncoder class JSONEncoder ( json . JSONEncoder ) [view_source] An extension of json.JSONEncoder that attempts to deal with all the crap you might splat into a log. Usage Usage with json.dump and json.dumps The encoder can be used with json.dump and json.dumps as follows. >>> from sys import stdout >>> json . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout , cls = JSONEncoder ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } >>> json . dumps ( dict ( x = 1 , y = 2 , z = 3 ), cls = JSONEncoder ) '{\"x\": 1, \"y\": 2, \"z\": 3}' Instance Usage However, usage with json.dump and json.dumps will create a new JSONEncoder instance for each call. It's more efficient to create a single instance and use it repeatedly. >>> encoder = JSONEncoder () The encoder provides a {@link pydoc:splatlog.json.json_encoder.JSONEncoder.dump} convenience method for (chunked) encoding to a file-like object. >>> encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } The inherited json.JSONEncoder.encode method stands-in for json.dumps . >>> encoder . encode ( dict ( x = 1 , y = 2 , z = 3 )) '{\"x\": 1, \"y\": 2, \"z\": 3}' Construction Helpers Construction helper class methods are provided for common instance configurations. The {@link pydoc:splatlog.json.json_encoder.JSONEncoder.pretty} helper creates instances that output \"pretty\" JSON by setting splatlog.json.json_encoder.JSONEncoder.indent to 4 . Useful for human-read output. >>> pretty_encoder = JSONEncoder . pretty () >>> pretty_encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } The {@link pydoc:splatlog.json.json_encoder.JSONEncoder.compact} helper creates instances that output the most compact JSON, limiting each output to a single line. Useful for machine-read output, especially log files. >>> compact_encoder = JSONEncoder . compact () >>> compact_encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } Extended Encoding Capabilities The whole point of this class is to be able to encode (far) more than the standard json.JSONEncoder . Extended capabilities are presented in resolution order \u2014 first one that applies wins... or loses; if that path fails for some reason, we don't keep trying down-list. Custom Handler Any object can implement a to_json_encodable method, and that will be used. >>> class A : ... def __init__ ( self , x , y , z ): ... self . x = x ... self . y = y ... self . z = z ... ... def to_json_encodable ( self ): ... return dict ( x = self . x , y = self . y , z = self . z ) >>> encoder . dump ( A ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } Classes Classes are encoded nominally as JSON strings, composed of the class __module__ and __qualname__ , joined with a . character. This is indented to keep information about the types of objects both specific and concise. >>> class B : ... pass >>> encoder . dump ( B , stdout ) \"splatlog.json.json_encoder.B\" For classes that are part of the top-level namespace (which have a __module__ of \"builtins\" ) the module part is omitted. Hence the top-level class str encodes simply as \"str\" , not as \"builtins.str\" . >>> encoder . dump ( str , stdout ) \"str\" Dataclasses Dataclass instances are encoded via dataclasses.asdict . >>> import dataclasses >>> @dataclasses . dataclass ... class DC : ... x : int ... y : int ... z : int >>> encoder . dump ( DC ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } Enums Instances of enum.Enum are encoded nominally as JSON strings, composed of the class of the object (per class encoding, discussed above) and the object's name , joined (again) with a . . >>> from enum import Enum >>> class Status ( Enum ): ... OK = \"ok\" ... ERROR = \"error\" >>> encoder . dump ( Status . OK , stdout ) \"splatlog.json.json_encoder.Status.OK\" Note that enums that descend from enum.IntEnum are automatically encoded by value via the standard JSON encoder. >>> from enum import IntEnum >>> class IntStatus ( IntEnum ): ... OK = 200 ... ERROR = 500 >>> encoder . dump ( IntStatus . OK , stdout ) 200 Exceptions Yes, JSONEncoder attempts to encode exceptions. At the most basic level, it tries to always give you the things you expect from an exception: the type of exception, and the message. The simplest version is an exception that was never raised, and hence has no traceback or cause. >>> pretty_encoder . dump ( RuntimeError ( \"Never raised\" ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"Never raised\" } In a more realistic scenario, the exception has been raised and has a traceback, which the encoder trawls through and encodes as well. >>> def capture_error ( fn , * args , ** kwds ): ... try : ... fn ( * args , ** kwds ) ... except BaseException as error : ... return error >>> def f (): ... raise RuntimeError ( \"Hey there\" ) >>> pretty_encoder . dump ( capture_error ( f ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"Hey there\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"capture_error\" , \"text\" : \"fn(*args, **kwds)\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"f\" , \"text\" : \"raise RuntimeError( \\\\ \" Hey there \\\\ \")\" } ] } To go even deeper, exceptions with an explicit cause also encode that cause. >>> def g ( f ): ... try : ... f () ... except Exception as error : ... raise RuntimeError ( f \" { f } threw up\" ) from error >>> pretty_encoder . dump ( capture_error ( g , f ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"<function f at ...> threw up\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"capture_error\" , \"text\" : \"fn(*args, **kwds)\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 5 , \"name\" : \"g\" , \"text\" : \"raise RuntimeError(f \\\\ \" { f } threw up \\\\ \") from error\" } ], \"cause\" : { \"type\" : \"RuntimeError\" , \"msg\" : \"Hey there\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"g\" , \"text\" : \"f()\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"f\" , \"text\" : \"raise RuntimeError( \\\\ \" Hey there \\\\ \")\" } ] } } Tracebacks Exhibited in the Exceptions section, but basically the encoder pulls the traceback.StackSummary and iterates through it's traceback.FrameSummay entries, encoding the attributes as (arguably) more general names. pretty_encoder.dump(capture_error(f). traceback , stdout) [ { \"file\": \" \", \"line\": 3, \"name\": \"capture_error\", \"text\": \"fn( args, * kwds)\" }, { \"file\": \" \", \"line\": 2, \"name\": \"f\", \"text\": \"raise RuntimeError(\\\"Hey there\\\")\" } ] Collections Objects that implement collections.abc.Collection are encoded as a JSON object containing the class and collection items. In the case of collections.abc.Mapping , items are encoded as a JSON object (via dict(collection) ). >>> from collections import UserDict >>> ud = UserDict ( dict ( a = 1 , b = 2 , c = 3 )) >>> pretty_encoder . dump ( ud , stdout ) { \"__class__\" : \"collections.UserDict\" , \"items\" : { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } } All other collections.abc.Collection have their items encoded as a JSON array (via tuple(collection) ). >>> pretty_encoder . dump ({ 1 , 2 , 3 }, stdout ) { \"__class__\" : \"set\" , \"items\" : [ 1 , 2 , 3 ] } Everything Else Because this encoder is focused on serializing log data that may contain any object, and that log data will often be examined only after said object is long gone, we try to provide a some-what useful catch-all. Anything that doesn't fall into any of the preceding categories will be encoded as a JSON object containing the __class__ (as a string, per the Classes section) and __repr__ . >>> pretty_encoder . dump ( lambda x : x , stdout ) { \"__class__\" : \"function\" , \"__repr__\" : \"<function <lambda> at ...>\" }","title":"json_encoder"},{"location":"splatlog/json/json_encoder/#splatlogjsonjson_encoder","text":"","title":"splatlog.json.json_encoder"},{"location":"splatlog/json/json_encoder/#jsonencoder","text":"class JSONEncoder ( json . JSONEncoder ) [view_source] An extension of json.JSONEncoder that attempts to deal with all the crap you might splat into a log.","title":"JSONEncoder"},{"location":"splatlog/json/json_encoder/#usage","text":"","title":"Usage"},{"location":"splatlog/json/json_encoder/#usage-with-jsondump-and-jsondumps","text":"The encoder can be used with json.dump and json.dumps as follows. >>> from sys import stdout >>> json . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout , cls = JSONEncoder ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } >>> json . dumps ( dict ( x = 1 , y = 2 , z = 3 ), cls = JSONEncoder ) '{\"x\": 1, \"y\": 2, \"z\": 3}'","title":"Usage with json.dump and json.dumps"},{"location":"splatlog/json/json_encoder/#instance-usage","text":"However, usage with json.dump and json.dumps will create a new JSONEncoder instance for each call. It's more efficient to create a single instance and use it repeatedly. >>> encoder = JSONEncoder () The encoder provides a {@link pydoc:splatlog.json.json_encoder.JSONEncoder.dump} convenience method for (chunked) encoding to a file-like object. >>> encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } The inherited json.JSONEncoder.encode method stands-in for json.dumps . >>> encoder . encode ( dict ( x = 1 , y = 2 , z = 3 )) '{\"x\": 1, \"y\": 2, \"z\": 3}'","title":"Instance Usage"},{"location":"splatlog/json/json_encoder/#construction-helpers","text":"Construction helper class methods are provided for common instance configurations. The {@link pydoc:splatlog.json.json_encoder.JSONEncoder.pretty} helper creates instances that output \"pretty\" JSON by setting splatlog.json.json_encoder.JSONEncoder.indent to 4 . Useful for human-read output. >>> pretty_encoder = JSONEncoder . pretty () >>> pretty_encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } The {@link pydoc:splatlog.json.json_encoder.JSONEncoder.compact} helper creates instances that output the most compact JSON, limiting each output to a single line. Useful for machine-read output, especially log files. >>> compact_encoder = JSONEncoder . compact () >>> compact_encoder . dump ( dict ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 }","title":"Construction Helpers"},{"location":"splatlog/json/json_encoder/#extended-encoding-capabilities","text":"The whole point of this class is to be able to encode (far) more than the standard json.JSONEncoder . Extended capabilities are presented in resolution order \u2014 first one that applies wins... or loses; if that path fails for some reason, we don't keep trying down-list.","title":"Extended Encoding Capabilities"},{"location":"splatlog/json/json_encoder/#custom-handler","text":"Any object can implement a to_json_encodable method, and that will be used. >>> class A : ... def __init__ ( self , x , y , z ): ... self . x = x ... self . y = y ... self . z = z ... ... def to_json_encodable ( self ): ... return dict ( x = self . x , y = self . y , z = self . z ) >>> encoder . dump ( A ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 }","title":"Custom Handler"},{"location":"splatlog/json/json_encoder/#classes","text":"Classes are encoded nominally as JSON strings, composed of the class __module__ and __qualname__ , joined with a . character. This is indented to keep information about the types of objects both specific and concise. >>> class B : ... pass >>> encoder . dump ( B , stdout ) \"splatlog.json.json_encoder.B\" For classes that are part of the top-level namespace (which have a __module__ of \"builtins\" ) the module part is omitted. Hence the top-level class str encodes simply as \"str\" , not as \"builtins.str\" . >>> encoder . dump ( str , stdout ) \"str\"","title":"Classes"},{"location":"splatlog/json/json_encoder/#dataclasses","text":"Dataclass instances are encoded via dataclasses.asdict . >>> import dataclasses >>> @dataclasses . dataclass ... class DC : ... x : int ... y : int ... z : int >>> encoder . dump ( DC ( x = 1 , y = 2 , z = 3 ), stdout ) { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 }","title":"Dataclasses"},{"location":"splatlog/json/json_encoder/#enums","text":"Instances of enum.Enum are encoded nominally as JSON strings, composed of the class of the object (per class encoding, discussed above) and the object's name , joined (again) with a . . >>> from enum import Enum >>> class Status ( Enum ): ... OK = \"ok\" ... ERROR = \"error\" >>> encoder . dump ( Status . OK , stdout ) \"splatlog.json.json_encoder.Status.OK\" Note that enums that descend from enum.IntEnum are automatically encoded by value via the standard JSON encoder. >>> from enum import IntEnum >>> class IntStatus ( IntEnum ): ... OK = 200 ... ERROR = 500 >>> encoder . dump ( IntStatus . OK , stdout ) 200","title":"Enums"},{"location":"splatlog/json/json_encoder/#exceptions","text":"Yes, JSONEncoder attempts to encode exceptions. At the most basic level, it tries to always give you the things you expect from an exception: the type of exception, and the message. The simplest version is an exception that was never raised, and hence has no traceback or cause. >>> pretty_encoder . dump ( RuntimeError ( \"Never raised\" ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"Never raised\" } In a more realistic scenario, the exception has been raised and has a traceback, which the encoder trawls through and encodes as well. >>> def capture_error ( fn , * args , ** kwds ): ... try : ... fn ( * args , ** kwds ) ... except BaseException as error : ... return error >>> def f (): ... raise RuntimeError ( \"Hey there\" ) >>> pretty_encoder . dump ( capture_error ( f ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"Hey there\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"capture_error\" , \"text\" : \"fn(*args, **kwds)\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"f\" , \"text\" : \"raise RuntimeError( \\\\ \" Hey there \\\\ \")\" } ] } To go even deeper, exceptions with an explicit cause also encode that cause. >>> def g ( f ): ... try : ... f () ... except Exception as error : ... raise RuntimeError ( f \" { f } threw up\" ) from error >>> pretty_encoder . dump ( capture_error ( g , f ), stdout ) { \"type\" : \"RuntimeError\" , \"msg\" : \"<function f at ...> threw up\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"capture_error\" , \"text\" : \"fn(*args, **kwds)\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 5 , \"name\" : \"g\" , \"text\" : \"raise RuntimeError(f \\\\ \" { f } threw up \\\\ \") from error\" } ], \"cause\" : { \"type\" : \"RuntimeError\" , \"msg\" : \"Hey there\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 3 , \"name\" : \"g\" , \"text\" : \"f()\" }, { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"f\" , \"text\" : \"raise RuntimeError( \\\\ \" Hey there \\\\ \")\" } ] } }","title":"Exceptions"},{"location":"splatlog/json/json_encoder/#tracebacks","text":"Exhibited in the Exceptions section, but basically the encoder pulls the traceback.StackSummary and iterates through it's traceback.FrameSummay entries, encoding the attributes as (arguably) more general names. pretty_encoder.dump(capture_error(f). traceback , stdout) [ { \"file\": \" \", \"line\": 3, \"name\": \"capture_error\", \"text\": \"fn( args, * kwds)\" }, { \"file\": \" \", \"line\": 2, \"name\": \"f\", \"text\": \"raise RuntimeError(\\\"Hey there\\\")\" } ]","title":"Tracebacks"},{"location":"splatlog/json/json_encoder/#collections","text":"Objects that implement collections.abc.Collection are encoded as a JSON object containing the class and collection items. In the case of collections.abc.Mapping , items are encoded as a JSON object (via dict(collection) ). >>> from collections import UserDict >>> ud = UserDict ( dict ( a = 1 , b = 2 , c = 3 )) >>> pretty_encoder . dump ( ud , stdout ) { \"__class__\" : \"collections.UserDict\" , \"items\" : { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } } All other collections.abc.Collection have their items encoded as a JSON array (via tuple(collection) ). >>> pretty_encoder . dump ({ 1 , 2 , 3 }, stdout ) { \"__class__\" : \"set\" , \"items\" : [ 1 , 2 , 3 ] }","title":"Collections"},{"location":"splatlog/json/json_encoder/#everything-else","text":"Because this encoder is focused on serializing log data that may contain any object, and that log data will often be examined only after said object is long gone, we try to provide a some-what useful catch-all. Anything that doesn't fall into any of the preceding categories will be encoded as a JSON object containing the __class__ (as a string, per the Classes section) and __repr__ . >>> pretty_encoder . dump ( lambda x : x , stdout ) { \"__class__\" : \"function\" , \"__repr__\" : \"<function <lambda> at ...>\" }","title":"Everything Else"},{"location":"splatlog/json/json_formatter/","text":"splatlog.json.json_formatter JSONFormatter class JSONFormatter ( logging . Formatter ) [view_source] Howdy format def format ( record : logging . LogRecord ) -> str [view_source] Examples Basic example. >>> from splatlog._testing import make_log_record >>> r_1 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ) ... ) >>> formatter = JSONFormatter ( ... encoder = JSONEncoder . pretty (), ... tz = timezone . utc , ... ) >>> print ( formatter . format ( r_1 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" } With some data attached. >>> from splatlog._testing import make_log_record >>> r_2 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ), ... data = dict ( ... x = 1 , ... y = 2 , ... ) ... ) >>> print ( formatter . format ( r_2 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" , \"data\" : { \"x\" : 1 , \"y\" : 2 } } With error information ( exc_info ). >>> import sys >>> from splatlog._testing import make_log_record >>> try : ... raise RuntimeError ( \"Something went wrong\" ) ... except : ... r_3 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ), ... exc_info = sys . exc_info (), ... ) ... print ( formatter . format ( r_3 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" , \"error\" : { \"type\" : \"RuntimeError\" , \"msg\" : \"Something went wrong\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"<module>\" , \"text\" : \"raise RuntimeError( \\\\ \" Something went wrong \\\\ \")\" } ] } }","title":"json_formatter"},{"location":"splatlog/json/json_formatter/#splatlogjsonjson_formatter","text":"","title":"splatlog.json.json_formatter"},{"location":"splatlog/json/json_formatter/#jsonformatter","text":"class JSONFormatter ( logging . Formatter ) [view_source] Howdy","title":"JSONFormatter"},{"location":"splatlog/json/json_formatter/#format","text":"def format ( record : logging . LogRecord ) -> str [view_source]","title":"format"},{"location":"splatlog/json/json_formatter/#examples","text":"Basic example. >>> from splatlog._testing import make_log_record >>> r_1 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ) ... ) >>> formatter = JSONFormatter ( ... encoder = JSONEncoder . pretty (), ... tz = timezone . utc , ... ) >>> print ( formatter . format ( r_1 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" } With some data attached. >>> from splatlog._testing import make_log_record >>> r_2 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ), ... data = dict ( ... x = 1 , ... y = 2 , ... ) ... ) >>> print ( formatter . format ( r_2 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" , \"data\" : { \"x\" : 1 , \"y\" : 2 } } With error information ( exc_info ). >>> import sys >>> from splatlog._testing import make_log_record >>> try : ... raise RuntimeError ( \"Something went wrong\" ) ... except : ... r_3 = make_log_record ( ... created = datetime ( ... 2022 , 9 , 4 , 3 , 4 , 5 , 123456 , tzinfo = timezone . utc ... ), ... exc_info = sys . exc_info (), ... ) ... print ( formatter . format ( r_3 )) { \"t\" : \"2022-09-04T03:04:05.123456Z\" , \"level\" : \"INFO\" , \"name\" : \"splatlog._testing\" , \"file\" : \".../splatlog/_testing.py\" , \"line\" : 123 , \"msg\" : \"Test message\" , \"error\" : { \"type\" : \"RuntimeError\" , \"msg\" : \"Something went wrong\" , \"traceback\" : [ { \"file\" : \"<doctest ...>\" , \"line\" : 2 , \"name\" : \"<module>\" , \"text\" : \"raise RuntimeError( \\\\ \" Something went wrong \\\\ \")\" } ] } }","title":"Examples"},{"location":"splatlog/json/json_typings/","text":"splatlog.json.json_typings","title":"json_typings"},{"location":"splatlog/json/json_typings/#splatlogjsonjson_typings","text":"","title":"splatlog.json.json_typings"},{"location":"splatlog/lib/","text":"splatlog.lib required_arity def required_arity ( fn : Callable ) -> int [view_source] Compute the number of required parameters for a collections.abc.Callable . Result includes positional-only, keyword-only, and position-or-keyword parameters. Examples >>> def f_1 (): ... pass >>> required_arity ( f_1 ) 0 >>> def f_2 ( x ): ... pass >>> required_arity ( f_2 ) 1 >>> def f_3 ( x = 1 ): ... pass >>> required_arity ( f_3 ) 0 >>> def f_4 ( x , y , * , w , z = 3 ): ... pass >>> required_arity ( f_4 ) 3 >>> def f_5 ( * args , ** kwds ): ... pass >>> required_arity ( f_5 ) 0 Ok, one weird corner-case to note... inspect.Parameter.default is set to inspect.Parameter.empty when the parameter does not have a default, as in f_req_x , which behaves as expected: >>> def f_req_x ( x ): ... return f \"x is { x } \" >>> required_arity ( f_req_x ) 1 >>> f_req_x () Traceback ( most recent call last ): ... TypeError : f_req_x () missing 1 required positional argument : 'x' However the user can also explicitly define the parameter default to be inspect.Parameter.empty , as in f_empty_x , which causes odd behavior: >>> def f_empty_x ( x = Parameter . empty ): ... return f \"x is { x } \" This function measures a required arity of 1 for f_empty_x , as it can no longer tell that the default was set explicitly. >>> required_arity ( f_empty_x ) 1 However, f_empty_x can be called with no arguments. >>> f_empty_x () \"x is <class 'inspect._empty'>\" inspect.Signature.bind seems to get confused too. >>> signature ( f_empty_x ) . bind () Traceback ( most recent call last ): ... TypeError : missing a required argument : 'x' is_callable_with def is_callable_with ( fn : Callable , * args , ** kwds ) -> bool [view_source] Examples >>> def f ( x , y , z ): ... pass >>> is_callable_with ( f , 1 , 2 , z = 3 ) True >>> is_callable_with ( f , 1 , 2 ) False","title":"splatlog.lib"},{"location":"splatlog/lib/#splatloglib","text":"","title":"splatlog.lib"},{"location":"splatlog/lib/#required_arity","text":"def required_arity ( fn : Callable ) -> int [view_source] Compute the number of required parameters for a collections.abc.Callable . Result includes positional-only, keyword-only, and position-or-keyword parameters.","title":"required_arity"},{"location":"splatlog/lib/#examples","text":">>> def f_1 (): ... pass >>> required_arity ( f_1 ) 0 >>> def f_2 ( x ): ... pass >>> required_arity ( f_2 ) 1 >>> def f_3 ( x = 1 ): ... pass >>> required_arity ( f_3 ) 0 >>> def f_4 ( x , y , * , w , z = 3 ): ... pass >>> required_arity ( f_4 ) 3 >>> def f_5 ( * args , ** kwds ): ... pass >>> required_arity ( f_5 ) 0 Ok, one weird corner-case to note... inspect.Parameter.default is set to inspect.Parameter.empty when the parameter does not have a default, as in f_req_x , which behaves as expected: >>> def f_req_x ( x ): ... return f \"x is { x } \" >>> required_arity ( f_req_x ) 1 >>> f_req_x () Traceback ( most recent call last ): ... TypeError : f_req_x () missing 1 required positional argument : 'x' However the user can also explicitly define the parameter default to be inspect.Parameter.empty , as in f_empty_x , which causes odd behavior: >>> def f_empty_x ( x = Parameter . empty ): ... return f \"x is { x } \" This function measures a required arity of 1 for f_empty_x , as it can no longer tell that the default was set explicitly. >>> required_arity ( f_empty_x ) 1 However, f_empty_x can be called with no arguments. >>> f_empty_x () \"x is <class 'inspect._empty'>\" inspect.Signature.bind seems to get confused too. >>> signature ( f_empty_x ) . bind () Traceback ( most recent call last ): ... TypeError : missing a required argument : 'x'","title":"Examples"},{"location":"splatlog/lib/#is_callable_with","text":"def is_callable_with ( fn : Callable , * args , ** kwds ) -> bool [view_source]","title":"is_callable_with"},{"location":"splatlog/lib/#examples_1","text":">>> def f ( x , y , z ): ... pass >>> is_callable_with ( f , 1 , 2 , z = 3 ) True >>> is_callable_with ( f , 1 , 2 ) False","title":"Examples"},{"location":"splatlog/lib/collections/","text":"splatlog.lib.collections each def each ( * targets , descend = default_each_descend , deep = True ) [view_source] Examples >>> list ( each ( None )) [] >>> list ( each ( 1 , 2 , [ 3 , [ 4 ]])) [ 1 , 2 , 3 , 4 ] >>> list ( each ( 1 , [ 2 , [ 3 , 4 ]], deep = False )) [ 1 , 2 , [ 3 , 4 ]] >>> list ( each ( \"abc\" , None , \"def\" )) [ 'abc' , 'def' ] >>> def char_descend ( target ): ... return isinstance ( target , Iterable ) and ( ... ( not isinstance ( target , str )) ... or len ( target ) > 1 ... ) >>> list ( each ( \"abc\" , [ \"def\" , \"ghi\" ], descend = char_descend )) [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' ] partition_mapping def partition_mapping ( mapping : Mapping [ TKey , TValue ], by : Union [ Container , Callable [[ TKey ], bool ]] ) -> tuple [ dict [ TKey , TValue ], dict [ TKey , TValue ]] [view_source] Examples >>> partition_mapping ( ... { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 , \"d\" : 4 }, ... { \"a\" , \"c\" } ... ) ({ 'a' : 1 , 'c' : 3 }, { 'b' : 2 , 'd' : 4 }) group_by def group_by ( iterable : Iterable [ TEntry ], get_key : Callable [[ TEntry ], TKey ]) -> dict [ TKey , list [ TEntry ]] [view_source] Aggregate entries in iterable by the result of calling get_key on them. The entries are stored in list instances, which are indexed by their common get_key result in a dict . \ud83d\udcdd NOTE This is different than functools.groupby , which takes a sort-of stream-like approach of iterating through the entries and breaking up groups when the result of the key function changes. Examples >>> group_by ( ... [ ... { \"name\" : \"Hudie\" , \"type\" : \"cat\" }, ... { \"name\" : \"Rice Card\" , \"type\" : \"human\" }, ... { \"name\" : \"Oscar\" , \"type\" : \"cat\" }, ... { \"name\" : \"Kid Cloud\" , \"type\" : \"human\" }, ... ], ... lambda dct : dct [ \"type\" ], ... ) ... # This is a little weird because NORMALIZE_WHITESPACE treats all ... # whitespace as equivalent, but you can't _add_ whitespace places there ... # was none. ... # ... # SEE https://stackoverflow.com/a/17640475 ... # { 'cat' : [{ 'name' : 'Hudie' , 'type' : 'cat' }, { 'name' : 'Oscar' , 'type' : 'cat' }], 'human' : [{ 'name' : 'Rice Card' , 'type' : 'human' }, { 'name' : 'Kid Cloud' , 'type' : 'human' }]}","title":"collections"},{"location":"splatlog/lib/collections/#splatloglibcollections","text":"","title":"splatlog.lib.collections"},{"location":"splatlog/lib/collections/#each","text":"def each ( * targets , descend = default_each_descend , deep = True ) [view_source]","title":"each"},{"location":"splatlog/lib/collections/#examples","text":">>> list ( each ( None )) [] >>> list ( each ( 1 , 2 , [ 3 , [ 4 ]])) [ 1 , 2 , 3 , 4 ] >>> list ( each ( 1 , [ 2 , [ 3 , 4 ]], deep = False )) [ 1 , 2 , [ 3 , 4 ]] >>> list ( each ( \"abc\" , None , \"def\" )) [ 'abc' , 'def' ] >>> def char_descend ( target ): ... return isinstance ( target , Iterable ) and ( ... ( not isinstance ( target , str )) ... or len ( target ) > 1 ... ) >>> list ( each ( \"abc\" , [ \"def\" , \"ghi\" ], descend = char_descend )) [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' ]","title":"Examples"},{"location":"splatlog/lib/collections/#partition_mapping","text":"def partition_mapping ( mapping : Mapping [ TKey , TValue ], by : Union [ Container , Callable [[ TKey ], bool ]] ) -> tuple [ dict [ TKey , TValue ], dict [ TKey , TValue ]] [view_source]","title":"partition_mapping"},{"location":"splatlog/lib/collections/#examples_1","text":">>> partition_mapping ( ... { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 , \"d\" : 4 }, ... { \"a\" , \"c\" } ... ) ({ 'a' : 1 , 'c' : 3 }, { 'b' : 2 , 'd' : 4 })","title":"Examples"},{"location":"splatlog/lib/collections/#group_by","text":"def group_by ( iterable : Iterable [ TEntry ], get_key : Callable [[ TEntry ], TKey ]) -> dict [ TKey , list [ TEntry ]] [view_source] Aggregate entries in iterable by the result of calling get_key on them. The entries are stored in list instances, which are indexed by their common get_key result in a dict . \ud83d\udcdd NOTE This is different than functools.groupby , which takes a sort-of stream-like approach of iterating through the entries and breaking up groups when the result of the key function changes.","title":"group_by"},{"location":"splatlog/lib/collections/#examples_2","text":">>> group_by ( ... [ ... { \"name\" : \"Hudie\" , \"type\" : \"cat\" }, ... { \"name\" : \"Rice Card\" , \"type\" : \"human\" }, ... { \"name\" : \"Oscar\" , \"type\" : \"cat\" }, ... { \"name\" : \"Kid Cloud\" , \"type\" : \"human\" }, ... ], ... lambda dct : dct [ \"type\" ], ... ) ... # This is a little weird because NORMALIZE_WHITESPACE treats all ... # whitespace as equivalent, but you can't _add_ whitespace places there ... # was none. ... # ... # SEE https://stackoverflow.com/a/17640475 ... # { 'cat' : [{ 'name' : 'Hudie' , 'type' : 'cat' }, { 'name' : 'Oscar' , 'type' : 'cat' }], 'human' : [{ 'name' : 'Rice Card' , 'type' : 'human' }, { 'name' : 'Kid Cloud' , 'type' : 'human' }]}","title":"Examples"},{"location":"splatlog/lib/colors/","text":"splatlog.lib.colors as_hex_byte def as_hex_byte ( n : float ) [view_source] Convert n in [0, 1] to a hex byte as you would use in a hex representation of an RGB color. Examples >>> as_hex_byte ( 0 ) '00' >>> as_hex_byte ( 1 ) 'ff' >>> as_hex_byte ( 0.12345 ) '1f' >>> as_hex_byte ( 1.23 ) Traceback ( most recent call last ): ... ValueError : ` n ` must be between 0 and 1 ( inclusive ), given 1.23","title":"colors"},{"location":"splatlog/lib/colors/#splatloglibcolors","text":"","title":"splatlog.lib.colors"},{"location":"splatlog/lib/colors/#as_hex_byte","text":"def as_hex_byte ( n : float ) [view_source] Convert n in [0, 1] to a hex byte as you would use in a hex representation of an RGB color.","title":"as_hex_byte"},{"location":"splatlog/lib/colors/#examples","text":">>> as_hex_byte ( 0 ) '00' >>> as_hex_byte ( 1 ) 'ff' >>> as_hex_byte ( 0.12345 ) '1f' >>> as_hex_byte ( 1.23 ) Traceback ( most recent call last ): ... ValueError : ` n ` must be between 0 and 1 ( inclusive ), given 1.23","title":"Examples"},{"location":"splatlog/lib/proxy/","text":"splatlog.lib.proxy","title":"proxy"},{"location":"splatlog/lib/proxy/#splatloglibproxy","text":"","title":"splatlog.lib.proxy"},{"location":"splatlog/lib/typeguard/","text":"splatlog.lib.typeguard","title":"typeguard"},{"location":"splatlog/lib/typeguard/#splatloglibtypeguard","text":"","title":"splatlog.lib.typeguard"},{"location":"splatlog/lib/functions/","text":"splatlog.lib.functions","title":"splatlog.lib.functions"},{"location":"splatlog/lib/functions/#splatloglibfunctions","text":"","title":"splatlog.lib.functions"},{"location":"splatlog/lib/functions/slot_cached_property/","text":"splatlog.lib.functions.slot_cached_property SlotCachedProperty class SlotCachedProperty ( Generic [ TValue ]) [view_source] This is basically just an adaptation of functools.cached_property that works with types that use __slots__ . If you have a property named blah you must have a slot named _blah for it to go in.","title":"slot_cached_property"},{"location":"splatlog/lib/functions/slot_cached_property/#splatloglibfunctionsslot_cached_property","text":"","title":"splatlog.lib.functions.slot_cached_property"},{"location":"splatlog/lib/functions/slot_cached_property/#slotcachedproperty","text":"class SlotCachedProperty ( Generic [ TValue ]) [view_source] This is basically just an adaptation of functools.cached_property that works with types that use __slots__ . If you have a property named blah you must have a slot named _blah for it to go in.","title":"SlotCachedProperty"},{"location":"splatlog/lib/rich/","text":"splatlog.lib.rich Helpers for working with rich","title":"splatlog.lib.rich"},{"location":"splatlog/lib/rich/#splatloglibrich","text":"Helpers for working with rich","title":"splatlog.lib.rich"},{"location":"splatlog/lib/rich/constants/","text":"splatlog.lib.rich.constants","title":"constants"},{"location":"splatlog/lib/rich/constants/#splatloglibrichconstants","text":"","title":"splatlog.lib.rich.constants"},{"location":"splatlog/lib/rich/enrich/","text":"splatlog.lib.rich.enrich","title":"enrich"},{"location":"splatlog/lib/rich/enrich/#splatloglibrichenrich","text":"","title":"splatlog.lib.rich.enrich"},{"location":"splatlog/lib/rich/enriched_type/","text":"splatlog.lib.rich.enriched_type EnrichedType class EnrichedType () [view_source] Wraps a class object in a rich.console.ConsoleRenderable that either prints it as a single line (if there is space) or a tree-like stack, distinctly styling the module and class name so they're easy to pick out. Examples >>> wide = Console ( width = 80 ) >>> narrow = Console ( width = 30 ) >>> class MyType : ... pass >>> wide . print ( EnrichedType ( MyType )) splatlog . lib . rich . enriched_type . MyType >>> narrow . print ( EnrichedType ( MyType )) splatlog . lib . rich . enriched_type . MyType","title":"enriched_type"},{"location":"splatlog/lib/rich/enriched_type/#splatloglibrichenriched_type","text":"","title":"splatlog.lib.rich.enriched_type"},{"location":"splatlog/lib/rich/enriched_type/#enrichedtype","text":"class EnrichedType () [view_source] Wraps a class object in a rich.console.ConsoleRenderable that either prints it as a single line (if there is space) or a tree-like stack, distinctly styling the module and class name so they're easy to pick out.","title":"EnrichedType"},{"location":"splatlog/lib/rich/enriched_type/#examples","text":">>> wide = Console ( width = 80 ) >>> narrow = Console ( width = 30 ) >>> class MyType : ... pass >>> wide . print ( EnrichedType ( MyType )) splatlog . lib . rich . enriched_type . MyType >>> narrow . print ( EnrichedType ( MyType )) splatlog . lib . rich . enriched_type . MyType","title":"Examples"},{"location":"splatlog/lib/rich/inline/","text":"splatlog.lib.rich.inline","title":"inline"},{"location":"splatlog/lib/rich/inline/#splatloglibrichinline","text":"","title":"splatlog.lib.rich.inline"},{"location":"splatlog/lib/rich/ntv_table/","text":"splatlog.lib.rich.ntv_table","title":"ntv_table"},{"location":"splatlog/lib/rich/ntv_table/#splatloglibrichntv_table","text":"","title":"splatlog.lib.rich.ntv_table"},{"location":"splatlog/lib/rich/typings/","text":"splatlog.lib.rich.typings RichTyped @runtime_checkable class RichTyped ( Protocol ) [view_source] An extension of the \"rich dunder protocol\" system to allow classes to control how their type is printed by Rich. As an extension, the protocol is not used by Rich itself, but is preferred by splatlog.lib.rich.enrich_type to format object types. Examples The method should be defined as a classmethod since the class is the receiver that makes sense. In this case, we'll define a class A that will print it's module and class name in a rich.panel.Panel . >>> from rich.panel import Panel >>> class A : ... @classmethod ... def __rich_type__ ( cls ) -> RenderableType : ... return Panel ( cls . __module__ + \".\" + cls . __qualname__ ) Note that both the A class and instances will test as expressing the protocol. >>> isinstance ( A , RichTyped ) True >>> isinstance ( A (), RichTyped ) True To wrap things up we'll create an instance of A , extract it's \"Rich type\" with splatlog.lib.rich.enrich_type , and print our panel! >>> from rich.console import Console >>> from splatlog.lib.rich import enrich_type >>> a = A () >>> Console ( width = 40 ) . print ( enrich_type ( a )) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 splatlog . lib . rich . typings . A \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f is_rich def is_rich ( x : object ) -> TypeGuard [ Rich ] [view_source] Is an object \"rich\"? This amounts to: Fullfilling one of the protocols: rich.console.ConsoleRenderable \u2014 having a __rich_console__ method, the signature of which is: def __rich_console__ ( self , console : rich . console . Console , options : rich . console . ConsoleOptions ) -> rich . console . RenderResult : ... rich.console.RichCast \u2014 having a ` rich method, the signature of which is: def __rich__ ( self ) -> rich . console . RenderableType : ... Not being a class (tested with inspect.isclass ). This check is applied a few places in the Rich rendering code, and is there because a simple check like hasattr ( renderable , \"__rich_console__\" ) is used to test if an object fullfills the protocols from (1). Those attributes are assumed to be instance methods , which show up as attributes on the class objects as well. The additional not isclass ( renderable ) check prevents erroneously calling those instance methods on the class objects.","title":"typings"},{"location":"splatlog/lib/rich/typings/#splatloglibrichtypings","text":"","title":"splatlog.lib.rich.typings"},{"location":"splatlog/lib/rich/typings/#richtyped","text":"@runtime_checkable class RichTyped ( Protocol ) [view_source] An extension of the \"rich dunder protocol\" system to allow classes to control how their type is printed by Rich. As an extension, the protocol is not used by Rich itself, but is preferred by splatlog.lib.rich.enrich_type to format object types.","title":"RichTyped"},{"location":"splatlog/lib/rich/typings/#examples","text":"The method should be defined as a classmethod since the class is the receiver that makes sense. In this case, we'll define a class A that will print it's module and class name in a rich.panel.Panel . >>> from rich.panel import Panel >>> class A : ... @classmethod ... def __rich_type__ ( cls ) -> RenderableType : ... return Panel ( cls . __module__ + \".\" + cls . __qualname__ ) Note that both the A class and instances will test as expressing the protocol. >>> isinstance ( A , RichTyped ) True >>> isinstance ( A (), RichTyped ) True To wrap things up we'll create an instance of A , extract it's \"Rich type\" with splatlog.lib.rich.enrich_type , and print our panel! >>> from rich.console import Console >>> from splatlog.lib.rich import enrich_type >>> a = A () >>> Console ( width = 40 ) . print ( enrich_type ( a )) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 splatlog . lib . rich . typings . A \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Examples"},{"location":"splatlog/lib/rich/typings/#is_rich","text":"def is_rich ( x : object ) -> TypeGuard [ Rich ] [view_source] Is an object \"rich\"? This amounts to: Fullfilling one of the protocols: rich.console.ConsoleRenderable \u2014 having a __rich_console__ method, the signature of which is: def __rich_console__ ( self , console : rich . console . Console , options : rich . console . ConsoleOptions ) -> rich . console . RenderResult : ... rich.console.RichCast \u2014 having a ` rich method, the signature of which is: def __rich__ ( self ) -> rich . console . RenderableType : ... Not being a class (tested with inspect.isclass ). This check is applied a few places in the Rich rendering code, and is there because a simple check like hasattr ( renderable , \"__rich_console__\" ) is used to test if an object fullfills the protocols from (1). Those attributes are assumed to be instance methods , which show up as attributes on the class objects as well. The additional not isclass ( renderable ) check prevents erroneously calling those instance methods on the class objects.","title":"is_rich"},{"location":"splatlog/lib/rich/formatter/","text":"splatlog.lib.rich.formatter Examples \ud83d\udcdd NOTE You can verify these example using doctest with a command similar to python -m doctest -v -o NORMALIZE_WHITESPACE -o ELLIPSIS <file> Note that {@link pydoc:splatlog} and it's dependencies must be available to Python. If you've checked out the repository just stick poetry run in front of the command and it should work. Prelude Before anything we need to import RichFormatter , as well as the standard library modules that we'll use in the examples. >>> from typing import * >>> from dataclasses import dataclass >>> import rich >>> from rich.text import Text >>> from splatlog.lib.rich.formatter import RichFormatter General Use RichFormatter instances combine literal text and interpolated objects into rich.text.Text instances. The default field formatting looks for a __rich_text__ method on values and, if found, invokes it to produce a rich.text.Text instance to interpolate. If __rich_text__ is not implemented, it falls back to repr formatting with syntax highlighting. Let's take a look at a dataclass , where the dataclasses.dataclass decorator has generated a nice __repr__ implementation for us. You won't be able to see the highlight coloring here because it's automatically stripped when writing to sys.stdout in the doctest (and it seems like it would be quite a pain to test for the control codes in the test), so you'll have to just trust us it will appear in normal use. >>> formatter = RichFormatter () >>> @dataclass ... class Point : ... x : float ... y : float >>> point = Point ( x = 1.23 , y = 4.56 ) >>> text = formatter . format ( \"The point is: {} , cool huh?\" , point ) >>> isinstance ( text , Text ) True >>> rich . print ( text ) The point is : Point ( x = 1.23 , y = 4.56 ), cool huh ? \ud83d\udcdd NOTE Dataclasses are used in many of these examples simply due to their concise definitions. Unless otherwise mentioned the same approach applies to \"normal\" classes as well. Conversions As of writing (2022-12-23, Python 3.10), string.Formatter defines three conversions , invoked by a formate string suffix of ! followed by the conversion character: !r \u2014 repr conversion. !s \u2014 str conversion. !a \u2014 ascii conversion. All are supported, plus one addition: !t \u2014 text conversion. You can also overriding or provide additional conversions via the conversions argument to the RichFormatter constructor. The default conversions implementations are described below. !r \u2014 Repr Conversion Uses the Rich Repr Protocol if the value supports it. Otherwise calls repr on the value and highlights the result with rich.highlighter.ReprHighlighter . >>> rich . print ( formatter . format ( \"The point is: {!r} , cool huh?\" , point )) The point is : Point ( x = 1.23 , y = 4.56 ), cool huh ? !s \u2014 String Conversion The !s conversion calls str on the interpolation value and wraps the result in a rich.text.Text , without applying any highlighting. To demonstrate, we define a class with a custom __str__ implementation. >>> class SomeClass : ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... def __str__ ( self ) -> str : ... return f \" { self . __class__ . __name__ } named ' { self . name } '\" >>> rich . print ( ... formatter . format ( \"We got {!s} over here!\" , SomeClass ( name = \"Classy Class\" )) ... ) We got SomeClass named 'Classy Class' over here ! !a \u2014 ascii Conversion Simply runs ascii on the value and highlights the result with rich.highlighter.ReprHighlighter . >>> @dataclass ... class UnicodeNamed : ... name : str >>> rich . print ( ... formatter . format ( ... \"Lookin' at {!a} in ascii.\" , UnicodeNamed ( name = \"\u03bb\" ) ... ) ... ) Lookin ' at UnicodeNamed(name=' \\ u03bb ') in ascii. !t \u2014 Text Conversion Uses the Rich Text Protocol if the value supports it, otherwise falls back to Repr Conversion . Custom Conversions For no really good reason, you can add or override conversions in the RichFormatter constructor. Conversions take the type RichFormatterConverter , which has form (typing.Any) -> rich.text.Text and you need to provide a mapping of str to converter, which is merged over the standard conversions, allowing you to override them if you really want. >>> weird_formatter = RichFormatter ( ... conversions = dict ( ... m = lambda v : Text . from_markup ( str ( v )), ... ), ... ) >>> @dataclass ... class Smiles : ... name : str ... ... def __str__ ( self ) -> str : ... return f \":smile: { self . name } :smile:\" >>> rich . print ( ... weird_formatter . format ( \"Hello, my name is {!s} \" , Smiles ( name = \"nrser\" )) ... ) Hello , my name is : smile : nrser : smile : >>> rich . print ( ... weird_formatter . format ( \"Hello, my name is {!m}\" , Smiles ( name = \"nrser\" )) ... ) Hello , my name is \ud83d\ude04 nrser \ud83d\ude04 __rich_text__ \u2014 Rich Text Protocol For full control of formatting classes can implement the RichText protocol, which consists of defining a single method __rich_text__ that takes no arguments and returns a rich.text.Text instance. >>> @dataclass ... class CustomFormatted : ... name : str ... ... def __rich_text__ ( self ) -> Text : ... return Text . from_markup ( f \":smile: { self . name } :smile:\" ) >>> custom_formatted = CustomFormatted ( name = \"Hey yo!\" ) >>> rich . print ( ... formatter . format ( ... \"Rendered with RichText protocol: {} . Pretty neat!\" , ... custom_formatted ... ) ... ) Rendered with RichText protocol : \ud83d\ude04 Hey yo ! \ud83d\ude04 . Pretty neat ! RichText is a typing.Protocol that is typing.runtime_checkable , allowing isinstance checks, should you have a use for them. >>> from splatlog.lib.rich.formatter import RichText >>> isinstance ( custom_formatted , RichText ) True __rich_repr__ \u2014 Rich Repr Protocol The Rich Repr Protocol is some-what supported... RichFormatter will iterate over the fields provided by __rich_repr__ and respect the omission of those set to their default, but RichFormatter does not traverse into the child attrbiutes (it simply does repr formatting and highlighting on them). More could be done; a bit of a todo. >>> from rich.repr import RichReprResult >>> class RichRepred : ... BEST_NAME = \"nrser\" ... BEST_QUEST = \"get rich\" ... BEST_COLOR = \"blue\" ... ... name : str ... quest : str ... fav_color : str ... ... def __init__ ( ... self , ... name : str , ... quest : str = BEST_QUEST , ... fav_color : str = BEST_COLOR , ... ): ... self . name = name ... self . quest = quest ... self . fav_color = fav_color ... ... def __rich_repr__ ( self ) -> RichReprResult : ... yield \"name\" , self . name ... yield \"quest\" , self . quest , self . BEST_QUEST ... yield \"fav_color\" , self . fav_color , self . BEST_COLOR >>> using_defaults = RichRepred ( name = \"Finn\" ) >>> rich . print ( formatter . format ( \"Got {} here!\" , using_defaults )) Got RichRepred ( name = 'Finn' ) here ! >>> no_defaults = RichRepred ( ... name = \"Smokey\" , ... quest = \"eat food\" , ... fav_color = \"red\" , ... ) >>> rich . print ( formatter . format ( \"Got {} here!\" , no_defaults )) Got RichRepred ( name = 'Smokey' , quest = 'eat food' , fav_color = 'red' ) here ! Field Formatting Field formatting is some-what supported, though the effects have not been thoroughly explored at this time (2022-12-27). The general approach that seems to have emerged during development is: If no conversion or field format spec is provided then format the value with the text conversion ( !t ). This defaults to the text_convert function, which uses __rich_text__ if available and falls back to repr_convert . This the RichFormatter analog to how string.Formatter defaults to str conversion. The fallback to repr_convert is because repr formatting is generally a lot more interesting and useful in the \"rich sense\" than plain string formatting. You should be able to field-format rich.text.Text like it was a str . The same as string.Formatter allows you to convert to a str with !s or !r then apply string formatting, like >>> \" {!r:<24} {!r:>24} \" . format ( Point ( 1 , 2 ), Point ( 333 , 444 )) 'Point(x=1, y=2) Point(x=333, y=444)' you should be able to do something similar with RichFormatter , even though it works with rich.text.Text : >>> rich . print ( ... formatter . format ( ... \" {!r:<24} {!r:>24} \" , Point ( 1 , 2 ), Point ( 333 , 444 ) ... ) ... ) Point ( x = 1 , y = 2 ) Point ( x = 333 , y = 444 ) This is accomplished by applying the formatting to the rich.text.Text.plain representation (which is a str ). Field format specs that work with string.Formatter should also work with RichFormatter . In essence, this means that if you provide a (non-empty) field format spec and an object whose __format__ method knows what to do with it, it should produce the expected result. An example of this is datetime.datetime instances, which have a __format__ method that understands a specific date/time format spec. >>> from datetime import datetime >>> today = datetime ( 2022 , 12 , 27 ) >>> \"Today is: {: %a %b %d %Y}\" . format ( today ) 'Today is: Tue Dec 27 2022' >>> rich . print ( formatter . format ( \"Today is: {: %a %b %d %Y}\" , today )) Today is : Tue Dec 27 2022 \ud83d\udcdd NOTE This complicates things quite a bit, as object itself also provides a __format__ method, which we call the trivial implementation : if the format spec is empty, it calls str on itself and returns the value. Otherwise it raises a TypeError . Considering the different ways an object can (loosely-speaking) \"have a method\" \u2014 Python method, built-in method, descriptor that returns a function, function slapped in __dict__ or __slots__ , etc. \u2014 and the wonkyness of class and instance methods sharing the same namespace, it's less than strait-forward to figure out what a typing.Callable attribute is and where it came from, so we play it safe and invoke __format__ on the object when: We were given a non-empty field format specification, and the object is not a rich.text.Text (either provided that way or as the result of a conversion). There is likely room to improve here in the future, but this seems tenable for the initial implementation.","title":"Index"},{"location":"splatlog/lib/rich/formatter/#splatloglibrichformatter","text":"","title":"splatlog.lib.rich.formatter"},{"location":"splatlog/lib/rich/formatter/#examples","text":"\ud83d\udcdd NOTE You can verify these example using doctest with a command similar to python -m doctest -v -o NORMALIZE_WHITESPACE -o ELLIPSIS <file> Note that {@link pydoc:splatlog} and it's dependencies must be available to Python. If you've checked out the repository just stick poetry run in front of the command and it should work.","title":"Examples"},{"location":"splatlog/lib/rich/formatter/#prelude","text":"Before anything we need to import RichFormatter , as well as the standard library modules that we'll use in the examples. >>> from typing import * >>> from dataclasses import dataclass >>> import rich >>> from rich.text import Text >>> from splatlog.lib.rich.formatter import RichFormatter","title":"Prelude"},{"location":"splatlog/lib/rich/formatter/#general-use","text":"RichFormatter instances combine literal text and interpolated objects into rich.text.Text instances. The default field formatting looks for a __rich_text__ method on values and, if found, invokes it to produce a rich.text.Text instance to interpolate. If __rich_text__ is not implemented, it falls back to repr formatting with syntax highlighting. Let's take a look at a dataclass , where the dataclasses.dataclass decorator has generated a nice __repr__ implementation for us. You won't be able to see the highlight coloring here because it's automatically stripped when writing to sys.stdout in the doctest (and it seems like it would be quite a pain to test for the control codes in the test), so you'll have to just trust us it will appear in normal use. >>> formatter = RichFormatter () >>> @dataclass ... class Point : ... x : float ... y : float >>> point = Point ( x = 1.23 , y = 4.56 ) >>> text = formatter . format ( \"The point is: {} , cool huh?\" , point ) >>> isinstance ( text , Text ) True >>> rich . print ( text ) The point is : Point ( x = 1.23 , y = 4.56 ), cool huh ? \ud83d\udcdd NOTE Dataclasses are used in many of these examples simply due to their concise definitions. Unless otherwise mentioned the same approach applies to \"normal\" classes as well.","title":"General Use"},{"location":"splatlog/lib/rich/formatter/#conversions","text":"As of writing (2022-12-23, Python 3.10), string.Formatter defines three conversions , invoked by a formate string suffix of ! followed by the conversion character: !r \u2014 repr conversion. !s \u2014 str conversion. !a \u2014 ascii conversion. All are supported, plus one addition: !t \u2014 text conversion. You can also overriding or provide additional conversions via the conversions argument to the RichFormatter constructor. The default conversions implementations are described below.","title":"Conversions"},{"location":"splatlog/lib/rich/formatter/#r-repr-conversion","text":"Uses the Rich Repr Protocol if the value supports it. Otherwise calls repr on the value and highlights the result with rich.highlighter.ReprHighlighter . >>> rich . print ( formatter . format ( \"The point is: {!r} , cool huh?\" , point )) The point is : Point ( x = 1.23 , y = 4.56 ), cool huh ?","title":"!r \u2014 Repr Conversion"},{"location":"splatlog/lib/rich/formatter/#s-string-conversion","text":"The !s conversion calls str on the interpolation value and wraps the result in a rich.text.Text , without applying any highlighting. To demonstrate, we define a class with a custom __str__ implementation. >>> class SomeClass : ... name : str ... ... def __init__ ( self , name : str ): ... self . name = name ... ... def __str__ ( self ) -> str : ... return f \" { self . __class__ . __name__ } named ' { self . name } '\" >>> rich . print ( ... formatter . format ( \"We got {!s} over here!\" , SomeClass ( name = \"Classy Class\" )) ... ) We got SomeClass named 'Classy Class' over here !","title":"!s \u2014 String Conversion"},{"location":"splatlog/lib/rich/formatter/#a-ascii-conversion","text":"Simply runs ascii on the value and highlights the result with rich.highlighter.ReprHighlighter . >>> @dataclass ... class UnicodeNamed : ... name : str >>> rich . print ( ... formatter . format ( ... \"Lookin' at {!a} in ascii.\" , UnicodeNamed ( name = \"\u03bb\" ) ... ) ... ) Lookin ' at UnicodeNamed(name=' \\ u03bb ') in ascii.","title":"!a \u2014 ascii Conversion"},{"location":"splatlog/lib/rich/formatter/#t-text-conversion","text":"Uses the Rich Text Protocol if the value supports it, otherwise falls back to Repr Conversion .","title":"!t \u2014 Text Conversion"},{"location":"splatlog/lib/rich/formatter/#custom-conversions","text":"For no really good reason, you can add or override conversions in the RichFormatter constructor. Conversions take the type RichFormatterConverter , which has form (typing.Any) -> rich.text.Text and you need to provide a mapping of str to converter, which is merged over the standard conversions, allowing you to override them if you really want. >>> weird_formatter = RichFormatter ( ... conversions = dict ( ... m = lambda v : Text . from_markup ( str ( v )), ... ), ... ) >>> @dataclass ... class Smiles : ... name : str ... ... def __str__ ( self ) -> str : ... return f \":smile: { self . name } :smile:\" >>> rich . print ( ... weird_formatter . format ( \"Hello, my name is {!s} \" , Smiles ( name = \"nrser\" )) ... ) Hello , my name is : smile : nrser : smile : >>> rich . print ( ... weird_formatter . format ( \"Hello, my name is {!m}\" , Smiles ( name = \"nrser\" )) ... ) Hello , my name is \ud83d\ude04 nrser \ud83d\ude04","title":"Custom Conversions"},{"location":"splatlog/lib/rich/formatter/#__rich_text__-rich-text-protocol","text":"For full control of formatting classes can implement the RichText protocol, which consists of defining a single method __rich_text__ that takes no arguments and returns a rich.text.Text instance. >>> @dataclass ... class CustomFormatted : ... name : str ... ... def __rich_text__ ( self ) -> Text : ... return Text . from_markup ( f \":smile: { self . name } :smile:\" ) >>> custom_formatted = CustomFormatted ( name = \"Hey yo!\" ) >>> rich . print ( ... formatter . format ( ... \"Rendered with RichText protocol: {} . Pretty neat!\" , ... custom_formatted ... ) ... ) Rendered with RichText protocol : \ud83d\ude04 Hey yo ! \ud83d\ude04 . Pretty neat ! RichText is a typing.Protocol that is typing.runtime_checkable , allowing isinstance checks, should you have a use for them. >>> from splatlog.lib.rich.formatter import RichText >>> isinstance ( custom_formatted , RichText ) True","title":"__rich_text__ \u2014 Rich Text Protocol"},{"location":"splatlog/lib/rich/formatter/#__rich_repr__-rich-repr-protocol","text":"The Rich Repr Protocol is some-what supported... RichFormatter will iterate over the fields provided by __rich_repr__ and respect the omission of those set to their default, but RichFormatter does not traverse into the child attrbiutes (it simply does repr formatting and highlighting on them). More could be done; a bit of a todo. >>> from rich.repr import RichReprResult >>> class RichRepred : ... BEST_NAME = \"nrser\" ... BEST_QUEST = \"get rich\" ... BEST_COLOR = \"blue\" ... ... name : str ... quest : str ... fav_color : str ... ... def __init__ ( ... self , ... name : str , ... quest : str = BEST_QUEST , ... fav_color : str = BEST_COLOR , ... ): ... self . name = name ... self . quest = quest ... self . fav_color = fav_color ... ... def __rich_repr__ ( self ) -> RichReprResult : ... yield \"name\" , self . name ... yield \"quest\" , self . quest , self . BEST_QUEST ... yield \"fav_color\" , self . fav_color , self . BEST_COLOR >>> using_defaults = RichRepred ( name = \"Finn\" ) >>> rich . print ( formatter . format ( \"Got {} here!\" , using_defaults )) Got RichRepred ( name = 'Finn' ) here ! >>> no_defaults = RichRepred ( ... name = \"Smokey\" , ... quest = \"eat food\" , ... fav_color = \"red\" , ... ) >>> rich . print ( formatter . format ( \"Got {} here!\" , no_defaults )) Got RichRepred ( name = 'Smokey' , quest = 'eat food' , fav_color = 'red' ) here !","title":"__rich_repr__ \u2014 Rich Repr Protocol"},{"location":"splatlog/lib/rich/formatter/#field-formatting","text":"Field formatting is some-what supported, though the effects have not been thoroughly explored at this time (2022-12-27). The general approach that seems to have emerged during development is: If no conversion or field format spec is provided then format the value with the text conversion ( !t ). This defaults to the text_convert function, which uses __rich_text__ if available and falls back to repr_convert . This the RichFormatter analog to how string.Formatter defaults to str conversion. The fallback to repr_convert is because repr formatting is generally a lot more interesting and useful in the \"rich sense\" than plain string formatting. You should be able to field-format rich.text.Text like it was a str . The same as string.Formatter allows you to convert to a str with !s or !r then apply string formatting, like >>> \" {!r:<24} {!r:>24} \" . format ( Point ( 1 , 2 ), Point ( 333 , 444 )) 'Point(x=1, y=2) Point(x=333, y=444)' you should be able to do something similar with RichFormatter , even though it works with rich.text.Text : >>> rich . print ( ... formatter . format ( ... \" {!r:<24} {!r:>24} \" , Point ( 1 , 2 ), Point ( 333 , 444 ) ... ) ... ) Point ( x = 1 , y = 2 ) Point ( x = 333 , y = 444 ) This is accomplished by applying the formatting to the rich.text.Text.plain representation (which is a str ). Field format specs that work with string.Formatter should also work with RichFormatter . In essence, this means that if you provide a (non-empty) field format spec and an object whose __format__ method knows what to do with it, it should produce the expected result. An example of this is datetime.datetime instances, which have a __format__ method that understands a specific date/time format spec. >>> from datetime import datetime >>> today = datetime ( 2022 , 12 , 27 ) >>> \"Today is: {: %a %b %d %Y}\" . format ( today ) 'Today is: Tue Dec 27 2022' >>> rich . print ( formatter . format ( \"Today is: {: %a %b %d %Y}\" , today )) Today is : Tue Dec 27 2022 \ud83d\udcdd NOTE This complicates things quite a bit, as object itself also provides a __format__ method, which we call the trivial implementation : if the format spec is empty, it calls str on itself and returns the value. Otherwise it raises a TypeError . Considering the different ways an object can (loosely-speaking) \"have a method\" \u2014 Python method, built-in method, descriptor that returns a function, function slapped in __dict__ or __slots__ , etc. \u2014 and the wonkyness of class and instance methods sharing the same namespace, it's less than strait-forward to figure out what a typing.Callable attribute is and where it came from, so we play it safe and invoke __format__ on the object when: We were given a non-empty field format specification, and the object is not a rich.text.Text (either provided that way or as the result of a conversion). There is likely room to improve here in the future, but this seems tenable for the initial implementation.","title":"Field Formatting"},{"location":"splatlog/lib/rich/formatter/rich_formatter/","text":"splatlog.lib.rich.formatter.rich_formatter RichFormatter class RichFormatter ( Formatter ) [view_source] An extension of string.Formatter that interpolates into rich.text.Text instances.","title":"rich_formatter"},{"location":"splatlog/lib/rich/formatter/rich_formatter/#splatloglibrichformatterrich_formatter","text":"","title":"splatlog.lib.rich.formatter.rich_formatter"},{"location":"splatlog/lib/rich/formatter/rich_formatter/#richformatter","text":"class RichFormatter ( Formatter ) [view_source] An extension of string.Formatter that interpolates into rich.text.Text instances.","title":"RichFormatter"},{"location":"splatlog/lib/rich/formatter/rich_repr/","text":"splatlog.lib.rich.formatter.rich_repr","title":"rich_repr"},{"location":"splatlog/lib/rich/formatter/rich_repr/#splatloglibrichformatterrich_repr","text":"","title":"splatlog.lib.rich.formatter.rich_repr"},{"location":"splatlog/lib/rich/formatter/rich_text/","text":"splatlog.lib.rich.formatter.rich_text implements_rich_text def implements_rich_text ( x : object ) -> TypeGuard [ RichText ] [view_source] Test if an object implements the RichText protocol. This amounts to testing if x is a an instance of the RichText protocol (using isinstance , as RichText is typing.runtime_checkable ), and x is not a class (using inspect.isclass ), as the __rich_text__ method is assumed to be an instance method. RichText @runtime_checkable class RichText ( Protocol ) [view_source] typing.Protocol for the Rich Text protocol (invented here), which lets an object define how it should be converted into a rich.text.Text for interpolation by RichFormatter . \u2757\u2757 WARNING \u2757\u2757 Though RichText is typing.runtime_checkable , use implements_rich_text to test if an object implements the protocol, as isinstance will also return True for class objects themselves that provide the __rich_text__ instance method . Examples isinstance Gotcha Classes that define __rich_text__ as an instance method will also test as \"instances\" of RichText via isinstance . This is a general gotcha due to how class and instance methods share the same namespace in Python. Notice that classes that implement the protocol for their instances will also test as instances of the protocol. It's easiest to just look at an example: >>> class RichTexter : ... def __rich_text__ ( self ) -> Text : ... return repr_highlight ( self ) >>> isinstance ( RichTexter , RichText ) True However, caling __rich_text on the class will (of course) fail: >>> RichTexter . __rich_text__ () Traceback ( most recent call last ): ... TypeError : RichTexter . __rich_text__ () missing 1 required positional argument : 'self' This issue is addressed by Rich by additionally rejecting class objects (using inspect.isclass to test), as seen here: https://github.com/Textualize/rich/blob/v12.6.0/rich/console.py#L1305 https://github.com/Textualize/rich/blob/v12.6.0/rich/pretty.py#L675 We follow the same pattern, exemplified in implements_rich_text . >>> implements_rich_text ( RichTexter ) False >>> rich_texter = RichTexter () >>> implements_rich_text ( rich_texter ) True","title":"rich_text"},{"location":"splatlog/lib/rich/formatter/rich_text/#splatloglibrichformatterrich_text","text":"","title":"splatlog.lib.rich.formatter.rich_text"},{"location":"splatlog/lib/rich/formatter/rich_text/#implements_rich_text","text":"def implements_rich_text ( x : object ) -> TypeGuard [ RichText ] [view_source] Test if an object implements the RichText protocol. This amounts to testing if x is a an instance of the RichText protocol (using isinstance , as RichText is typing.runtime_checkable ), and x is not a class (using inspect.isclass ), as the __rich_text__ method is assumed to be an instance method.","title":"implements_rich_text"},{"location":"splatlog/lib/rich/formatter/rich_text/#richtext","text":"@runtime_checkable class RichText ( Protocol ) [view_source] typing.Protocol for the Rich Text protocol (invented here), which lets an object define how it should be converted into a rich.text.Text for interpolation by RichFormatter . \u2757\u2757 WARNING \u2757\u2757 Though RichText is typing.runtime_checkable , use implements_rich_text to test if an object implements the protocol, as isinstance will also return True for class objects themselves that provide the __rich_text__ instance method .","title":"RichText"},{"location":"splatlog/lib/rich/formatter/rich_text/#examples","text":"","title":"Examples"},{"location":"splatlog/lib/rich/formatter/rich_text/#isinstance-gotcha","text":"Classes that define __rich_text__ as an instance method will also test as \"instances\" of RichText via isinstance . This is a general gotcha due to how class and instance methods share the same namespace in Python. Notice that classes that implement the protocol for their instances will also test as instances of the protocol. It's easiest to just look at an example: >>> class RichTexter : ... def __rich_text__ ( self ) -> Text : ... return repr_highlight ( self ) >>> isinstance ( RichTexter , RichText ) True However, caling __rich_text on the class will (of course) fail: >>> RichTexter . __rich_text__ () Traceback ( most recent call last ): ... TypeError : RichTexter . __rich_text__ () missing 1 required positional argument : 'self' This issue is addressed by Rich by additionally rejecting class objects (using inspect.isclass to test), as seen here: https://github.com/Textualize/rich/blob/v12.6.0/rich/console.py#L1305 https://github.com/Textualize/rich/blob/v12.6.0/rich/pretty.py#L675 We follow the same pattern, exemplified in implements_rich_text . >>> implements_rich_text ( RichTexter ) False >>> rich_texter = RichTexter () >>> implements_rich_text ( rich_texter ) True","title":"isinstance Gotcha"},{"location":"splatlog/lib/text/","text":"splatlog.lib.text get_name @FmtOpts . provide def get_name ( x : Any , opts : FmtOpts ) -> Optional [ str ] [view_source] Examples >>> get_name ( str ) 'str' >>> get_name ( str , omit_builtins = False ) 'builtins.str' >>> get_name ( get_name ) 'splatlog.lib.text.get_name' >>> get_name ( get_name , module_names = False ) 'get_name' >>> get_name ( FmtOpts ) 'splatlog.lib.text.FmtOpts' >>> get_name ( str . count ) 'str.count' >>> class Screwy : ... def __init__ ( self , name ): ... self . __qualname__ = name >>> get_name ( Screwy ( 123 )) is None True >>> get_name ( int . __add__ ) 'int.__add__' fmt @FmtOpts . provide def fmt ( x : Any , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source] Examples >>> fmt ( int . __add__ ) 'int.__add__()' fmt_routine @FmtOpts . provide def fmt_routine ( fn : types . FunctionType , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source] Examples >>> fmt_routine ( fmt_routine ) 'splatlog.lib.text.fmt_routine()' >>> fmt_routine ( fmt_routine , module_names = False ) 'fmt_routine()' >>> fmt_routine ( lambda x , y : x + y ) '\u03bb()' >>> def f (): ... def g (): ... pass ... return g >>> fmt_routine ( f ()) 'splatlog.lib.text.f.<locals>.g()' >>> fmt_routine ( FmtOpts . provide ) 'splatlog.lib.text.FmtOpts.provide()' fmt_type @FmtOpts . provide def fmt_type ( t : Type , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source] Examples >>> fmt_type ( abc . Collection ) 'collections.abc.Collection' >>> fmt_type ( abc . Collection , module_names = False ) 'Collection' >>> fmt_type ( abc . Collection , FmtOpts ( module_names = False )) 'Collection' >>> fmt_type ( abc . Collection , FmtOpts ( module_names = False ), module_names = True ) 'collections.abc.Collection' fmt_type_hint @FmtOpts . provide def fmt_type_hint ( t : Any , opts : FmtOpts [ TFallback ], * , nested : bool = False ) -> Union [ str , TFallback ] [view_source] Examples Examples can be found in .","title":"text"},{"location":"splatlog/lib/text/#splatloglibtext","text":"","title":"splatlog.lib.text"},{"location":"splatlog/lib/text/#get_name","text":"@FmtOpts . provide def get_name ( x : Any , opts : FmtOpts ) -> Optional [ str ] [view_source]","title":"get_name"},{"location":"splatlog/lib/text/#examples","text":">>> get_name ( str ) 'str' >>> get_name ( str , omit_builtins = False ) 'builtins.str' >>> get_name ( get_name ) 'splatlog.lib.text.get_name' >>> get_name ( get_name , module_names = False ) 'get_name' >>> get_name ( FmtOpts ) 'splatlog.lib.text.FmtOpts' >>> get_name ( str . count ) 'str.count' >>> class Screwy : ... def __init__ ( self , name ): ... self . __qualname__ = name >>> get_name ( Screwy ( 123 )) is None True >>> get_name ( int . __add__ ) 'int.__add__'","title":"Examples"},{"location":"splatlog/lib/text/#fmt","text":"@FmtOpts . provide def fmt ( x : Any , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source]","title":"fmt"},{"location":"splatlog/lib/text/#examples_1","text":">>> fmt ( int . __add__ ) 'int.__add__()'","title":"Examples"},{"location":"splatlog/lib/text/#fmt_routine","text":"@FmtOpts . provide def fmt_routine ( fn : types . FunctionType , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source]","title":"fmt_routine"},{"location":"splatlog/lib/text/#examples_2","text":">>> fmt_routine ( fmt_routine ) 'splatlog.lib.text.fmt_routine()' >>> fmt_routine ( fmt_routine , module_names = False ) 'fmt_routine()' >>> fmt_routine ( lambda x , y : x + y ) '\u03bb()' >>> def f (): ... def g (): ... pass ... return g >>> fmt_routine ( f ()) 'splatlog.lib.text.f.<locals>.g()' >>> fmt_routine ( FmtOpts . provide ) 'splatlog.lib.text.FmtOpts.provide()'","title":"Examples"},{"location":"splatlog/lib/text/#fmt_type","text":"@FmtOpts . provide def fmt_type ( t : Type , opts : FmtOpts [ TFallback ]) -> Union [ str , TFallback ] [view_source]","title":"fmt_type"},{"location":"splatlog/lib/text/#examples_3","text":">>> fmt_type ( abc . Collection ) 'collections.abc.Collection' >>> fmt_type ( abc . Collection , module_names = False ) 'Collection' >>> fmt_type ( abc . Collection , FmtOpts ( module_names = False )) 'Collection' >>> fmt_type ( abc . Collection , FmtOpts ( module_names = False ), module_names = True ) 'collections.abc.Collection'","title":"Examples"},{"location":"splatlog/lib/text/#fmt_type_hint","text":"@FmtOpts . provide def fmt_type_hint ( t : Any , opts : FmtOpts [ TFallback ], * , nested : bool = False ) -> Union [ str , TFallback ] [view_source]","title":"fmt_type_hint"},{"location":"splatlog/lib/text/#examples_4","text":"Examples can be found in .","title":"Examples"},{"location":"splatlog/lib/text/fmt_type_hint/","text":"fmt_type_hint Examples \ud83d\udcdd NOTE You can verify these example using doctest with a command similar to python -m doctest -v -o NORMALIZE_WHITESPACE -o ELLIPSIS <file> Note that {@link pydoc:splatlog} and it's dependencies must be available to Python. If you've checked out the repository just stick poetry run in front of the command and it should work. Prelude Before anything we need to import fmt_type_hint , as well as the standard library modules that we'll use in the examples. >>> from typing import * >>> import types >>> from collections import abc >>> from splatlog.lib.text import fmt_type_hint typing.Union and typing.Literal Unions and literals both have their formatted members joined with | characters. >>> fmt_type_hint ( Union [ int , str ]) 'int | str' >>> fmt_type_hint ( Literal [ \"a\" , \"b\" ]) \"'a' | 'b'\" >>> fmt_type_hint ( Union [ abc . Mapping , abc . Sequence ]) 'collections.abc.Mapping | collections.abc.Sequence' >>> fmt_type_hint ( Union [ abc . Mapping , abc . Sequence ], module_names = False ) 'Mapping | Sequence' We even smush union and literal combinations together, as they mean about the same thing and the differences in member formatting seem clear enough to tell what's going on. >>> fmt_type_hint ( Union [ int , str , Literal [ \"a\" , \"b\" ]]) \"int | str | 'a' | 'b'\" typing.Optional Optional types (which are really 2-arg typing.Union where one arg is types.NoneType ) are formatting the type arg that is not none and appending a ? character. >>> fmt_type_hint ( Optional [ int ]) 'int?' >>> fmt_type_hint ( Union [ None , int ]) 'int?' >>> fmt_type_hint ( Optional [ Literal [ \"a\" , \"b\" ]]) \"None | 'a' | 'b'\" Callable Simple example. >>> fmt_type_hint ( Callable [[ int , int ], float ]) '(int, int) -> float' Return types are not considered nested (they are not wrapped in parenthesis when they contain multiple tokens without start and end delimiters). >>> fmt_type_hint ( Callable [[ int , int ], Union [ int , float ]]) '(int, int) -> int | float' However, callables themselves will be paren-wrapped when nested, such as in unions. I feel like this makes it easier to pick the callables out as coherent terms. >>> fmt_type_hint ( ... Union [ ... Callable [[ int , int ], Union [ int , float ]], ... Callable [[ float , float ], Union [ int , float ]], ... ] ... ) '((int, int) -> int | float) | ((float, float) -> int | float)' PEP 585 \u2014 Type Hinting Generics In Standard Collections Using the standard collections as type hints, which I think is what we're supposed to be doing going forward? Even though it has some screwiness (as of 2022-09-27, Python 3.10). As if Python type hints needed more screwiness, right? Dictionaries >>> fmt_type_hint ( dict [ str , list ]) '{str: list}' >>> fmt_type_hint ( dict [ str , list [ int ]]) '{str: int[]}' >>> fmt_type_hint ( dict [ str , Optional [ int ]]) '{str: int?}' Tuples >>> fmt_type_hint ( tuple [ int , int ]) '(int, int)' >>> fmt_type_hint ( tuple [ str , ... ]) '(str, ...)' Sets >>> fmt_type_hint ( set [ str ]) ' {str} ' Lists >>> fmt_type_hint ( list [ int ]) 'int[]' >>> T = TypeVar ( \"T\" ) >>> fmt_type_hint ( list [ T ]) '~T[]' Callables >>> fmt_type_hint ( abc . Callable [[ int , int ], float ]) '(int, int) -> float' Screwiness You can give more args than makes sense using standard collections as type hints (try it using typing.Dict and it will barf). Type checkers should barf on it too: https://mypy-play.net/?mypy=latest&python=3.10&gist=d4ba8ac1d3c3e85de35b32ed6679c6e9 We simply ignore the extra args. >>> fmt_type_hint ( set [ int , str ]) ' {int} ' >>> fmt_type_hint ( dict [ str , int , float ]) '{str: int}'","title":"fmt_type_hint Examples"},{"location":"splatlog/lib/text/fmt_type_hint/#fmt_type_hint-examples","text":"\ud83d\udcdd NOTE You can verify these example using doctest with a command similar to python -m doctest -v -o NORMALIZE_WHITESPACE -o ELLIPSIS <file> Note that {@link pydoc:splatlog} and it's dependencies must be available to Python. If you've checked out the repository just stick poetry run in front of the command and it should work.","title":"fmt_type_hint Examples"},{"location":"splatlog/lib/text/fmt_type_hint/#prelude","text":"Before anything we need to import fmt_type_hint , as well as the standard library modules that we'll use in the examples. >>> from typing import * >>> import types >>> from collections import abc >>> from splatlog.lib.text import fmt_type_hint","title":"Prelude"},{"location":"splatlog/lib/text/fmt_type_hint/#typingunion-and-typingliteral","text":"Unions and literals both have their formatted members joined with | characters. >>> fmt_type_hint ( Union [ int , str ]) 'int | str' >>> fmt_type_hint ( Literal [ \"a\" , \"b\" ]) \"'a' | 'b'\" >>> fmt_type_hint ( Union [ abc . Mapping , abc . Sequence ]) 'collections.abc.Mapping | collections.abc.Sequence' >>> fmt_type_hint ( Union [ abc . Mapping , abc . Sequence ], module_names = False ) 'Mapping | Sequence' We even smush union and literal combinations together, as they mean about the same thing and the differences in member formatting seem clear enough to tell what's going on. >>> fmt_type_hint ( Union [ int , str , Literal [ \"a\" , \"b\" ]]) \"int | str | 'a' | 'b'\"","title":"typing.Union and typing.Literal"},{"location":"splatlog/lib/text/fmt_type_hint/#typingoptional","text":"Optional types (which are really 2-arg typing.Union where one arg is types.NoneType ) are formatting the type arg that is not none and appending a ? character. >>> fmt_type_hint ( Optional [ int ]) 'int?' >>> fmt_type_hint ( Union [ None , int ]) 'int?' >>> fmt_type_hint ( Optional [ Literal [ \"a\" , \"b\" ]]) \"None | 'a' | 'b'\"","title":"typing.Optional"},{"location":"splatlog/lib/text/fmt_type_hint/#callable","text":"Simple example. >>> fmt_type_hint ( Callable [[ int , int ], float ]) '(int, int) -> float' Return types are not considered nested (they are not wrapped in parenthesis when they contain multiple tokens without start and end delimiters). >>> fmt_type_hint ( Callable [[ int , int ], Union [ int , float ]]) '(int, int) -> int | float' However, callables themselves will be paren-wrapped when nested, such as in unions. I feel like this makes it easier to pick the callables out as coherent terms. >>> fmt_type_hint ( ... Union [ ... Callable [[ int , int ], Union [ int , float ]], ... Callable [[ float , float ], Union [ int , float ]], ... ] ... ) '((int, int) -> int | float) | ((float, float) -> int | float)'","title":"Callable"},{"location":"splatlog/lib/text/fmt_type_hint/#pep-585-type-hinting-generics-in-standard-collections","text":"Using the standard collections as type hints, which I think is what we're supposed to be doing going forward? Even though it has some screwiness (as of 2022-09-27, Python 3.10). As if Python type hints needed more screwiness, right?","title":"PEP 585 \u2014 Type Hinting Generics In Standard Collections"},{"location":"splatlog/lib/text/fmt_type_hint/#dictionaries","text":">>> fmt_type_hint ( dict [ str , list ]) '{str: list}' >>> fmt_type_hint ( dict [ str , list [ int ]]) '{str: int[]}' >>> fmt_type_hint ( dict [ str , Optional [ int ]]) '{str: int?}'","title":"Dictionaries"},{"location":"splatlog/lib/text/fmt_type_hint/#tuples","text":">>> fmt_type_hint ( tuple [ int , int ]) '(int, int)' >>> fmt_type_hint ( tuple [ str , ... ]) '(str, ...)'","title":"Tuples"},{"location":"splatlog/lib/text/fmt_type_hint/#sets","text":">>> fmt_type_hint ( set [ str ]) ' {str} '","title":"Sets"},{"location":"splatlog/lib/text/fmt_type_hint/#lists","text":">>> fmt_type_hint ( list [ int ]) 'int[]' >>> T = TypeVar ( \"T\" ) >>> fmt_type_hint ( list [ T ]) '~T[]'","title":"Lists"},{"location":"splatlog/lib/text/fmt_type_hint/#callables","text":">>> fmt_type_hint ( abc . Callable [[ int , int ], float ]) '(int, int) -> float'","title":"Callables"},{"location":"splatlog/lib/text/fmt_type_hint/#screwiness","text":"You can give more args than makes sense using standard collections as type hints (try it using typing.Dict and it will barf). Type checkers should barf on it too: https://mypy-play.net/?mypy=latest&python=3.10&gist=d4ba8ac1d3c3e85de35b32ed6679c6e9 We simply ignore the extra args. >>> fmt_type_hint ( set [ int , str ]) ' {int} ' >>> fmt_type_hint ( dict [ str , int , float ]) '{str: int}'","title":"Screwiness"},{"location":"splatlog/verbosity/","text":"splatlog.verbosity","title":"splatlog.verbosity"},{"location":"splatlog/verbosity/#splatlogverbosity","text":"","title":"splatlog.verbosity"},{"location":"splatlog/verbosity/verbosity_level_resolver/","text":"splatlog.verbosity.verbosity_level_resolver The VerbosityLevelResolver class. VerbosityLevelResolver class VerbosityLevelResolver () [view_source] Resolves a splatlog.typing.Verbosity to a splatlog.typing.LevelValue against a set of splatlog.typing.VerbosityLevel . Basically, normalizes verbosity / log level pairings and facilitates their efficient query. Instances are immutable (via public API). Examples >>> import logging >>> resolver = VerbosityLevelResolver ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) >>> resolver . levels (( 0 , 'ERROR' ), ( 1 , 'WARNING' ), ( 3 , 'INFO' ), ( 5 , 'DEBUG' )) >>> resolver . ranges (( range ( 0 , 1 ), 40 ), ( range ( 1 , 3 ), 30 ), ( range ( 3 , 5 ), 20 ), ( range ( 5 , ... ), 10 )) >>> resolver . get_level ( 0 ) == logging . ERROR True >>> resolver . get_level ( 1 ) == logging . WARNING True >>> resolver . get_level ( 4 ) == logging . INFO True >>> resolver . get_level ( 5 ) == logging . DEBUG True compute_verbosity_ranges @staticmethod def compute_verbosity_ranges ( verbosity_levels : Iterable [ VerbosityLevel ] ) -> tuple [ VerbosityRange , ... ] [view_source] Turn a set of ( Verbosity , LevelValue ) pairs into an ordered list (well, tuple , to be precise) of non-overlapping range of Verbosity paired to the corespoding LevelValue . Examples >>> VerbosityLevelResolver . compute_verbosity_ranges ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) (( range ( 0 , 1 ), 40 ), ( range ( 1 , 3 ), 30 ), ( range ( 3 , 5 ), 20 ), ( range ( 5 , ... ), 10 )) cast @classmethod def cast ( cls : type [ Self ], value : Union [ Iterable [ VerbosityLevel ], Self ]) -> Self [view_source] Create an instance out of value if value is not already one. Examples >>> resolver = VerbosityLevelResolver . cast ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) >>> isinstance ( resolver , VerbosityLevelResolver ) True >>> VerbosityLevelResolver . cast ( resolver ) is resolver True __repr__ def __repr__ () -> str [view_source] Get a reasonably concise string representation of the instance. Examples >>> VerbosityLevelResolver ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) < VerbosityLevelResolver [ 0 ]: ERROR , [ 1 , 2 ]: WARNING , [ 3 , 4 ]: INFO , [ 5 , ... ]: DEBUG > levels @property def levels () -> tuple [ VerbosityLevel , ... ] [view_source] The verbosity/level mappings used to compute VerbosityRanges.ranges , as they were passed in at construction. ranges @property def ranges () -> tuple [ VerbosityRange , ... ] [view_source] The range/level mappings computed from `VerbosityRanges.levels. get_level def get_level ( verbosity : Verbosity ) -> LevelValue [view_source] Get the log level ( int value) for a verbosity, or logging.NOTSET if there is not one.","title":"verbosity_level_resolver"},{"location":"splatlog/verbosity/verbosity_level_resolver/#splatlogverbosityverbosity_level_resolver","text":"The VerbosityLevelResolver class.","title":"splatlog.verbosity.verbosity_level_resolver"},{"location":"splatlog/verbosity/verbosity_level_resolver/#verbositylevelresolver","text":"class VerbosityLevelResolver () [view_source] Resolves a splatlog.typing.Verbosity to a splatlog.typing.LevelValue against a set of splatlog.typing.VerbosityLevel . Basically, normalizes verbosity / log level pairings and facilitates their efficient query. Instances are immutable (via public API).","title":"VerbosityLevelResolver"},{"location":"splatlog/verbosity/verbosity_level_resolver/#examples","text":">>> import logging >>> resolver = VerbosityLevelResolver ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) >>> resolver . levels (( 0 , 'ERROR' ), ( 1 , 'WARNING' ), ( 3 , 'INFO' ), ( 5 , 'DEBUG' )) >>> resolver . ranges (( range ( 0 , 1 ), 40 ), ( range ( 1 , 3 ), 30 ), ( range ( 3 , 5 ), 20 ), ( range ( 5 , ... ), 10 )) >>> resolver . get_level ( 0 ) == logging . ERROR True >>> resolver . get_level ( 1 ) == logging . WARNING True >>> resolver . get_level ( 4 ) == logging . INFO True >>> resolver . get_level ( 5 ) == logging . DEBUG True","title":"Examples"},{"location":"splatlog/verbosity/verbosity_level_resolver/#compute_verbosity_ranges","text":"@staticmethod def compute_verbosity_ranges ( verbosity_levels : Iterable [ VerbosityLevel ] ) -> tuple [ VerbosityRange , ... ] [view_source] Turn a set of ( Verbosity , LevelValue ) pairs into an ordered list (well, tuple , to be precise) of non-overlapping range of Verbosity paired to the corespoding LevelValue .","title":"compute_verbosity_ranges"},{"location":"splatlog/verbosity/verbosity_level_resolver/#examples_1","text":">>> VerbosityLevelResolver . compute_verbosity_ranges ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) (( range ( 0 , 1 ), 40 ), ( range ( 1 , 3 ), 30 ), ( range ( 3 , 5 ), 20 ), ( range ( 5 , ... ), 10 ))","title":"Examples"},{"location":"splatlog/verbosity/verbosity_level_resolver/#cast","text":"@classmethod def cast ( cls : type [ Self ], value : Union [ Iterable [ VerbosityLevel ], Self ]) -> Self [view_source] Create an instance out of value if value is not already one.","title":"cast"},{"location":"splatlog/verbosity/verbosity_level_resolver/#examples_2","text":">>> resolver = VerbosityLevelResolver . cast ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) >>> isinstance ( resolver , VerbosityLevelResolver ) True >>> VerbosityLevelResolver . cast ( resolver ) is resolver True","title":"Examples"},{"location":"splatlog/verbosity/verbosity_level_resolver/#__repr__","text":"def __repr__ () -> str [view_source] Get a reasonably concise string representation of the instance.","title":"__repr__"},{"location":"splatlog/verbosity/verbosity_level_resolver/#examples_3","text":">>> VerbosityLevelResolver ( ... ( ... ( 0 , \"ERROR\" ), ... ( 1 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ) ... ) < VerbosityLevelResolver [ 0 ]: ERROR , [ 1 , 2 ]: WARNING , [ 3 , 4 ]: INFO , [ 5 , ... ]: DEBUG >","title":"Examples"},{"location":"splatlog/verbosity/verbosity_level_resolver/#levels","text":"@property def levels () -> tuple [ VerbosityLevel , ... ] [view_source] The verbosity/level mappings used to compute VerbosityRanges.ranges , as they were passed in at construction.","title":"levels"},{"location":"splatlog/verbosity/verbosity_level_resolver/#ranges","text":"@property def ranges () -> tuple [ VerbosityRange , ... ] [view_source] The range/level mappings computed from `VerbosityRanges.levels.","title":"ranges"},{"location":"splatlog/verbosity/verbosity_level_resolver/#get_level","text":"def get_level ( verbosity : Verbosity ) -> LevelValue [view_source] Get the log level ( int value) for a verbosity, or logging.NOTSET if there is not one.","title":"get_level"},{"location":"splatlog/verbosity/verbosity_levels_filter/","text":"splatlog.verbosity.verbosity_levels_filter The VerbosityLevelsFilter class. VerbosityLevelsFilter class VerbosityLevelsFilter ( logging . Filter ) [view_source] A logging.Filter that filters based on {@link pydoc:splatlog.typings.VerbosityLevels} and the current (global) {@link pydoc:splatlog.typings.Verbosity} value See Also get_verbosity Examples Here we create a filter that applies to a some_module logger (and all it's descendant loggers). >>> from splatlog._testing import make_log_record >>> import splatlog >>> filter = VerbosityLevelsFilter ( ... { ... \"some_module\" : ( ... ( 0 , \"WARNING\" ), ... ( 2 , \"INFO\" ), ... ( 4 , \"DEBUG\" ), ... ) ... } ... ) When verbosity is not set everything is allowed through. >>> splatlog . del_verbosity () >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) True Once verbosity is set the filter takes effect. >>> splatlog . set_verbosity ( 0 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) False >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) False >>> splatlog . set_verbosity ( 2 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) False >>> splatlog . set_verbosity ( 8 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) True Descendant loggers follow the same logic. >>> splatlog . set_verbosity ( 1 ) >>> filter . filter ( make_log_record ( name = \"some_module.blah\" , level = \"INFO\" )) False Loggers that are not descendants are all allowed through. >>> splatlog . set_verbosity ( 1 ) >>> filter . filter ( make_log_record ( name = \"other_module\" , level = \"INFO\" )) True","title":"verbosity_levels_filter"},{"location":"splatlog/verbosity/verbosity_levels_filter/#splatlogverbosityverbosity_levels_filter","text":"The VerbosityLevelsFilter class.","title":"splatlog.verbosity.verbosity_levels_filter"},{"location":"splatlog/verbosity/verbosity_levels_filter/#verbositylevelsfilter","text":"class VerbosityLevelsFilter ( logging . Filter ) [view_source] A logging.Filter that filters based on {@link pydoc:splatlog.typings.VerbosityLevels} and the current (global) {@link pydoc:splatlog.typings.Verbosity} value","title":"VerbosityLevelsFilter"},{"location":"splatlog/verbosity/verbosity_levels_filter/#see-also","text":"get_verbosity","title":"See Also"},{"location":"splatlog/verbosity/verbosity_levels_filter/#examples","text":"Here we create a filter that applies to a some_module logger (and all it's descendant loggers). >>> from splatlog._testing import make_log_record >>> import splatlog >>> filter = VerbosityLevelsFilter ( ... { ... \"some_module\" : ( ... ( 0 , \"WARNING\" ), ... ( 2 , \"INFO\" ), ... ( 4 , \"DEBUG\" ), ... ) ... } ... ) When verbosity is not set everything is allowed through. >>> splatlog . del_verbosity () >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) True Once verbosity is set the filter takes effect. >>> splatlog . set_verbosity ( 0 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) False >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) False >>> splatlog . set_verbosity ( 2 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) False >>> splatlog . set_verbosity ( 8 ) >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"WARNING\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"INFO\" )) True >>> filter . filter ( make_log_record ( name = \"some_module\" , level = \"DEBUG\" )) True Descendant loggers follow the same logic. >>> splatlog . set_verbosity ( 1 ) >>> filter . filter ( make_log_record ( name = \"some_module.blah\" , level = \"INFO\" )) False Loggers that are not descendants are all allowed through. >>> splatlog . set_verbosity ( 1 ) >>> filter . filter ( make_log_record ( name = \"other_module\" , level = \"INFO\" )) True","title":"Examples"},{"location":"splatlog/verbosity/verbosity_state/","text":"splatlog.verbosity.verbosity_state Manage verbosity and verbosity levels , which are stored as module-level private variables, and are hence global to the process. cast_verbosity_levels def cast_verbosity_levels ( verbosity_levels : VerbosityLevelsCastable ) -> VerbosityLevels [view_source] Create a VerbosityLevels mapping by applying cast to each value in verbosity_levels . Examples >>> cast_verbosity_levels ( ... { ... \"some_mod\" : ( ... ( 0 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ), ... \"other_mod\" : ( ... ( 0 , \"WARNING\" ), ... ( 1 , \"INFO\" ), ... ( 2 , \"DEBUG\" ), ... ), ... }, ... ) { 'some_mod' : < VerbosityLevelResolver [ 0 , 1 , 2 ]: WARNING , [ 3 , 4 ]: INFO , [ 5 , ... ]: DEBUG > , 'other_mod' : < VerbosityLevelResolver [ 0 ]: WARNING , [ 1 ]: INFO , [ 2 , ... ]: DEBUG > } get_verbosity_levels def get_verbosity_levels () -> VerbosityLevels [view_source] Get the current logger name / verbosity levels mapping. \ud83d\udcdd NOTE The returned collections.abc.Mapping is a copy of the one held in internal global state. Adding or removing items will have no effect that state. The copy is shallow \u2014 it references the actual VerbosityLevelConfig instances that are in use \u2014 but those are publically immutable. If you go modifying private attributes your on your own as far as {@link pydoc:splatlog} is concerned. set_verbosity_levels def set_verbosity_levels ( verbosity_levels : VerbosityLevelsCastable ) -> None [view_source] Set the global verbosity levels. If verbosity is set ( get_verbosity does not return None ) then any logger levels that appear to have been set by the old verbosity levels will be set to logging.NOTSET , then the loggers listed in verbosity_levels will be have their levels set according to the current verbosity value. \ud83d\udcdd NOTE There is not way to add or remove individual name / levels mappings. This is intentional as it avoids updating the internal global state and any thread-safe logic that may come with that; the entire dict is written as a single, unconditional set operation, which we understand to be thread-safe from Python's point of vue (via the GIL). If you need to modify the levels, do your own get-modify-set sequence and lock around it as needed for your application. Parameters verbosity_levels \u2014 Mapping of logger names to sets of Verbosity / LevelValue pairs. Examples >>> set_verbosity_levels ({ ... \"splatlog\" : ( ... ( 0 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 4 , \"DEBUG\" ), ... ), ... \"my.app\" : ( ... ( 0 , \"INFO\" ), ... ( 1 , \"DEBUG\" ), ... ) ... }) >>> get_verbosity_levels () { 'splatlog' : < VerbosityLevelResolver [ 0 , 1 , 2 ]: WARNING , [ 3 ]: INFO , [ 4 , ... ]: DEBUG > , 'my.app' : < VerbosityLevelResolver [ 0 ]: INFO , [ 1 , ... ]: DEBUG > } del_verbosity_levels def del_verbosity_levels () -> None [view_source] Remove all verbosity levels , restoring the mapping to empty. If verbosity is set ( get_verbosity does not return None ) then any loggers that appear to have had their level set by the outgoing verbosity level will have their level set to logging.NOTSET . get_verbosity def get_verbosity () -> Optional [ Verbosity ] [view_source] Get the current verbosity . \ud83d\udcdd NOTE \u2014 Thread Safety There is no locking around the read, it simply returns whatever value is visible to the thread at the time. This is because VerbosityLevelsFilter reads on every filter, so we want it to be fast. This does mean that the various logger levels are not guaranteed to be in a state consistent with the returned value if set_verbosity or del_verbosity are currently executing. set_verbosity def set_verbosity ( verbosity : Verbosity ) -> None [view_source] Set the verbosity . Any loggers named in the current verbosity levels will have their levels set accordingly. Examples >>> set_verbosity_levels ({ ... \"my.app\" : (( 0 , \"WARNING\" ), ( 1 , \"INFO\" ), ( 2 , \"DEBUG\" )), ... }) >>> set_verbosity ( 1 ) >>> logging . getLogger ( \"my.app\" ) . level == logging . INFO True del_verbosity def del_verbosity () -> None [view_source] Set the verbosity . Any loggers named in the current verbosity levels that appear to have had their levels set by the outgoing verbosity will have their level set to logging.NOTSET . Examples >>> set_verbosity_levels ({ ... \"my.app\" : (( 0 , \"WARNING\" ), ( 1 , \"INFO\" ), ( 2 , \"DEBUG\" )), ... }) >>> set_verbosity ( 1 ) >>> logging . getLogger ( \"my.app\" ) . level == logging . INFO True >>> del_verbosity () >>> logging . getLogger ( \"my.app\" ) . level == logging . NOTSET True","title":"verbosity_state"},{"location":"splatlog/verbosity/verbosity_state/#splatlogverbosityverbosity_state","text":"Manage verbosity and verbosity levels , which are stored as module-level private variables, and are hence global to the process.","title":"splatlog.verbosity.verbosity_state"},{"location":"splatlog/verbosity/verbosity_state/#cast_verbosity_levels","text":"def cast_verbosity_levels ( verbosity_levels : VerbosityLevelsCastable ) -> VerbosityLevels [view_source] Create a VerbosityLevels mapping by applying cast to each value in verbosity_levels .","title":"cast_verbosity_levels"},{"location":"splatlog/verbosity/verbosity_state/#examples","text":">>> cast_verbosity_levels ( ... { ... \"some_mod\" : ( ... ( 0 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 5 , \"DEBUG\" ), ... ), ... \"other_mod\" : ( ... ( 0 , \"WARNING\" ), ... ( 1 , \"INFO\" ), ... ( 2 , \"DEBUG\" ), ... ), ... }, ... ) { 'some_mod' : < VerbosityLevelResolver [ 0 , 1 , 2 ]: WARNING , [ 3 , 4 ]: INFO , [ 5 , ... ]: DEBUG > , 'other_mod' : < VerbosityLevelResolver [ 0 ]: WARNING , [ 1 ]: INFO , [ 2 , ... ]: DEBUG > }","title":"Examples"},{"location":"splatlog/verbosity/verbosity_state/#get_verbosity_levels","text":"def get_verbosity_levels () -> VerbosityLevels [view_source] Get the current logger name / verbosity levels mapping. \ud83d\udcdd NOTE The returned collections.abc.Mapping is a copy of the one held in internal global state. Adding or removing items will have no effect that state. The copy is shallow \u2014 it references the actual VerbosityLevelConfig instances that are in use \u2014 but those are publically immutable. If you go modifying private attributes your on your own as far as {@link pydoc:splatlog} is concerned.","title":"get_verbosity_levels"},{"location":"splatlog/verbosity/verbosity_state/#set_verbosity_levels","text":"def set_verbosity_levels ( verbosity_levels : VerbosityLevelsCastable ) -> None [view_source] Set the global verbosity levels. If verbosity is set ( get_verbosity does not return None ) then any logger levels that appear to have been set by the old verbosity levels will be set to logging.NOTSET , then the loggers listed in verbosity_levels will be have their levels set according to the current verbosity value. \ud83d\udcdd NOTE There is not way to add or remove individual name / levels mappings. This is intentional as it avoids updating the internal global state and any thread-safe logic that may come with that; the entire dict is written as a single, unconditional set operation, which we understand to be thread-safe from Python's point of vue (via the GIL). If you need to modify the levels, do your own get-modify-set sequence and lock around it as needed for your application.","title":"set_verbosity_levels"},{"location":"splatlog/verbosity/verbosity_state/#parameters","text":"verbosity_levels \u2014 Mapping of logger names to sets of Verbosity / LevelValue pairs.","title":"Parameters"},{"location":"splatlog/verbosity/verbosity_state/#examples_1","text":">>> set_verbosity_levels ({ ... \"splatlog\" : ( ... ( 0 , \"WARNING\" ), ... ( 3 , \"INFO\" ), ... ( 4 , \"DEBUG\" ), ... ), ... \"my.app\" : ( ... ( 0 , \"INFO\" ), ... ( 1 , \"DEBUG\" ), ... ) ... }) >>> get_verbosity_levels () { 'splatlog' : < VerbosityLevelResolver [ 0 , 1 , 2 ]: WARNING , [ 3 ]: INFO , [ 4 , ... ]: DEBUG > , 'my.app' : < VerbosityLevelResolver [ 0 ]: INFO , [ 1 , ... ]: DEBUG > }","title":"Examples"},{"location":"splatlog/verbosity/verbosity_state/#del_verbosity_levels","text":"def del_verbosity_levels () -> None [view_source] Remove all verbosity levels , restoring the mapping to empty. If verbosity is set ( get_verbosity does not return None ) then any loggers that appear to have had their level set by the outgoing verbosity level will have their level set to logging.NOTSET .","title":"del_verbosity_levels"},{"location":"splatlog/verbosity/verbosity_state/#get_verbosity","text":"def get_verbosity () -> Optional [ Verbosity ] [view_source] Get the current verbosity . \ud83d\udcdd NOTE \u2014 Thread Safety There is no locking around the read, it simply returns whatever value is visible to the thread at the time. This is because VerbosityLevelsFilter reads on every filter, so we want it to be fast. This does mean that the various logger levels are not guaranteed to be in a state consistent with the returned value if set_verbosity or del_verbosity are currently executing.","title":"get_verbosity"},{"location":"splatlog/verbosity/verbosity_state/#set_verbosity","text":"def set_verbosity ( verbosity : Verbosity ) -> None [view_source] Set the verbosity . Any loggers named in the current verbosity levels will have their levels set accordingly.","title":"set_verbosity"},{"location":"splatlog/verbosity/verbosity_state/#examples_2","text":">>> set_verbosity_levels ({ ... \"my.app\" : (( 0 , \"WARNING\" ), ( 1 , \"INFO\" ), ( 2 , \"DEBUG\" )), ... }) >>> set_verbosity ( 1 ) >>> logging . getLogger ( \"my.app\" ) . level == logging . INFO True","title":"Examples"},{"location":"splatlog/verbosity/verbosity_state/#del_verbosity","text":"def del_verbosity () -> None [view_source] Set the verbosity . Any loggers named in the current verbosity levels that appear to have had their levels set by the outgoing verbosity will have their level set to logging.NOTSET .","title":"del_verbosity"},{"location":"splatlog/verbosity/verbosity_state/#examples_3","text":">>> set_verbosity_levels ({ ... \"my.app\" : (( 0 , \"WARNING\" ), ( 1 , \"INFO\" ), ( 2 , \"DEBUG\" )), ... }) >>> set_verbosity ( 1 ) >>> logging . getLogger ( \"my.app\" ) . level == logging . INFO True >>> del_verbosity () >>> logging . getLogger ( \"my.app\" ) . level == logging . NOTSET True","title":"Examples"}]}